{"version":3,"sources":["ng://@babili.io/angular/configuration/babili.configuration.ts","ng://@babili.io/angular/configuration/token-configuration.types.ts","ng://@babili.io/angular/authentication/not-authorized-error.ts","ng://@babili.io/angular/authentication/http-authentication-interceptor.ts","ng://@babili.io/angular/user/user.types.ts","ng://@babili.io/angular/message/message.types.ts","ng://@babili.io/angular/message/message.repository.ts","ng://@babili.io/angular/room/room.types.ts","ng://@babili.io/angular/room/room.repository.ts","ng://@babili.io/angular/me/me.types.ts","ng://@babili.io/angular/me/me.repository.ts","ng://@babili.io/angular/socket/bootstrap.socket.ts","ng://@babili.io/angular/me/me.service.ts","ng://@babili.io/angular/pipe/sort-room.ts","ng://@babili.io/angular/babili.module.ts"],"names":["BabiliConfiguration","prototype","init","apiUrl","socketUrl","aliveIntervalInMs","this","url","Object","defineProperty","undefined","Injectable","TokenConfiguration","isApiTokenSet","apiToken","clear","NotAuthorizedError","error","HttpAuthenticationInterceptor","configuration","tokenConfiguration","intercept","request","next","shouldAddHeaderTo","handle","addHeaderTo","pipe","catchError","HttpErrorResponse","status","throwError","token","clone","headers","set","startsWith","User","id","build","json","attributes","map","moment","momentLoaded","Message","content","contentType","createdAt","sender","roomId","toDate","relationships","data","room","hasSenderId","userId","MessageRepository","http","create","post","messageUrl","type","response","findAll","get","params","delete","message","roomUrl","HttpClient","Room","name","lastActivityAt","open","unreadMessageCount","users","senders","messages","initiator","roomRepository","internalOpen","BehaviorSubject","internalLastActivityAt","internalName","internalUnreadMessageCount","internalImageUrl","messageRepository","utc","value","count","imageUrl","openMembership","updateMembership","closeMembership","markAllMessagesAsRead","markAllReceivedMessagesAsRead","addMessage","push","notifyNewMessage","newMessageNotifier","apply","hasUser","some","user","fetchMoreMessage","_this","firstSeenMessageId","length","findMessages","unshift","findMessageWithId","find","update","sendMessage","newMessage","createMessage","removeMessage","messageToDelete","index","findIndex","splice","deleteMessage","deletedMessage","replaceUsersWith","Array","addUser","RoomRepository","query","findOpenedRooms","onlyOpened","findClosedRooms","onlyClosed","findRoomsAfter","firstSeenRoomId","findRoomsByIds","roomIds","roomIds[]","put","lastReadMessageId","meta","of","userIds","withoutDuplicate","noDuplicate","newUser","Me","openedRooms","rooms","roomCount","internalRoomCount","fetchOpenedRooms","addRooms","fetchClosedRooms","fetchMoreRooms","firstSeenRoom","fetchRoomsById","fetchRoomById","addRoom","findOrFetchRoomById","findRoomById","handleNewMessage","subscribe","newRoom","hasRoom","isAfter","roomIndex","openRoom","hasRoomOpened","flatMap","openedRoom","addToOpenedRoom","closeRoom","closedRoom","removeFromOpenedRoom","closeRooms","roomsToClose","forEach","openRoomAndCloseOthers","roomToOpen","roomsToBeClosed","filter","hasOpenedRooms","createRoom","buildRoom","noId","toUser","deviceSessionId","isSentByMe","addUserTo","roomToFind","findRoom","findRoomOpened","readMessageCount","Math","max","MeRepository","findMe","userUrl","me","updateAliveness","aliveUrl","empty","BootstrapSocket","connect","socket","io.connect","forceNew","socketExists","disconnect","close","MeService","meRepository","socketClient","alive","setup","hasCachedMe","cachedMe","scheduleAliveness","publishReplay","refCount","share","connectSocket","timer","takeWhile","on","receiveNewMessage","SortRoomPipe","transform","field","sort","otherRoom","otherLastActivityAt","isBefore","Pipe","args","BabiliModule","forRoot","ngModule","providers","provide","HTTP_INTERCEPTORS","useClass","multi","NgModule","imports","HttpClientModule","declarations","exports"],"mappings":"ykBAAA,IAAAA,EAAA,gCAQEA,EAAAC,UAAAC,KAAA,SAAKC,EAAgBC,EAAmBC,GACtCC,KAAKC,IAAM,CACTJ,OAAQA,EACRC,UAAWA,EACXC,kBAAmBA,IAIvBG,OAAAC,eAAIT,EAAAC,UAAA,SAAM,KAAV,WACE,OAAOK,KAAKC,IAAMD,KAAKC,IAAIJ,OAASO,2CAGtCF,OAAAC,eAAIT,EAAAC,UAAA,YAAS,KAAb,WACE,OAAOK,KAAKC,IAAMD,KAAKC,IAAIH,UAAYM,2CAGzCF,OAAAC,eAAIT,EAAAC,UAAA,oBAAiB,KAArB,WACE,OAAOK,KAAKC,IAAMD,KAAKC,IAAIF,kBAAoB,yDAtBlDM,EAAAA,eAHD,GCAAC,EAAA,WAME,SAAAA,YAEAA,EAAAX,UAAAY,cAAA,WACE,OAAOP,KAAKQ,WAAaJ,WAA+B,OAAlBJ,KAAKQ,UAAuC,KAAlBR,KAAKQ,UAGvEF,EAAAX,UAAAc,MAAA,WACET,KAAKQ,SAAWJ,+BAXnBC,EAAAA,qDAFD,GCAAK,EACE,SAAqBC,GAAAX,KAAAW,MAAAA,GCDvBC,EAAA,WAWE,SAAAA,EAAoBC,EACAC,GADAd,KAAAa,cAAAA,EACAb,KAAAc,mBAAAA,SAEpBF,EAAAjB,UAAAoB,UAAA,SAAUC,EAA2BC,GACnC,OAAIjB,KAAKkB,kBAAkBF,GAClBC,EAAKE,OAAOnB,KAAKoB,YAAYJ,EAAShB,KAAKc,mBAAmBN,WACzDa,KAAKC,EAAAA,WAAW,SAAAX,GACf,OAAIA,aAAiBY,EAAAA,mBAAsC,MAAjBZ,EAAMa,OACvCC,EAAAA,WAAW,IAAIf,EAAmBC,IAElCc,EAAAA,WAAWd,MAI1BM,EAAKE,OAAOH,IAIfJ,EAAAjB,UAAAyB,qBAAYJ,EAA2BU,GAC7C,OAAOV,EAAQW,MAAM,CACnBC,QAASZ,EAAQY,QAAQC,IAAI,gBAAiB,UAAUH,MAIpDd,EAAAjB,UAAAuB,2BAAkBF,GACxB,OAAOA,EAAQf,IAAI6B,WAAW9B,KAAKa,cAAchB,6BA5BpDQ,EAAAA,sDANQX,SAGAY,OALT,GCAAyB,EAAA,WAiBE,SAAAA,EAAqBC,EACAR,GADAxB,KAAAgC,GAAAA,EACAhC,KAAAwB,OAAAA,SAjBdO,EAAAE,MAAP,SAAaC,GACX,OAAIA,EACK,IAAIH,EAAKG,EAAKF,GAAIE,EAAKC,WAAaD,EAAKC,WAAWX,OAASpB,WAE7DA,WAIJ2B,EAAAK,IAAP,SAAWF,GACT,OAAIA,EACKA,EAAKE,IAAIL,EAAKE,OAEd7B,aAbb,GCCMiC,EAASC,EAIfC,EAAA,WAoBE,SAAAA,EAAqBP,EACAQ,EACAC,EACAC,EACAC,EACAC,GALA5C,KAAAgC,GAAAA,EACAhC,KAAAwC,QAAAA,EACAxC,KAAAyC,YAAAA,EACAzC,KAAA0C,UAAAA,EACA1C,KAAA2C,OAAAA,EACA3C,KAAA4C,OAAAA,SAvBdL,EAAAN,MAAP,SAAaC,GACX,IAAMC,EAAaD,EAAKC,WACxB,OAAO,IAAII,EAAQL,EAAKF,GACJG,EAAWK,QACXL,EAAWM,YACXJ,EAAOF,EAAWO,WAAWG,SAC7BX,EAAKY,cAAcH,OAASZ,EAAKE,MAAMC,EAAKY,cAAcH,OAAOI,MAAQ3C,UACzE8B,EAAKY,cAAcE,KAAKD,KAAKf,KAG5CO,EAAAH,IAAP,SAAWF,GACT,OAAIA,EACKA,EAAKE,IAAIG,EAAQN,OAEjB7B,WAWXmC,EAAA5C,UAAAsD,YAAA,SAAYC,GACV,OAAOlD,KAAK2C,QAAU3C,KAAK2C,OAAOX,KAAOkB,KA5B7C,GCLAC,EAAA,WAiBE,SAAAA,EAAoBC,EACAvC,GADAb,KAAAoD,KAAAA,EACApD,KAAAa,cAAAA,SAEpBsC,EAAAxD,UAAA0D,OAAA,SAAOL,EAAYb,GACjB,OAAOnC,KAAKoD,KAAKE,KAAKtD,KAAKuD,WAAWP,EAAKhB,IAAK,CAC9Ce,KAAM,CACJS,KAAM,UACNrB,WAAYA,KAEbd,KAAKe,EAAAA,IAAI,SAACqB,GAAkB,OAAAlB,EAAQN,MAAMwB,EAASV,UAGxDI,EAAAxD,UAAA+D,QAAA,SAAQV,EAAYb,GAClB,OAAOnC,KAAKoD,KAAKO,IAAI3D,KAAKuD,WAAWP,EAAKhB,IAAK,CAAE4B,OAAQzB,IACxCd,KAAKe,EAAAA,IAAI,SAACqB,GAAkB,OAAAlB,EAAQH,IAAIqB,EAASV,UAGpEI,EAAAxD,UAAAkE,UAAA,SAAOb,EAAYc,GACjB,OAAO9D,KAAKoD,KAAKS,UAAU7D,KAAKuD,WAAWP,EAAKhB,IAAG,IAAI8B,EAAQ9B,IAC9CX,KAAKe,EAAAA,IAAI,SAAAqB,GAAY,OAAAK,MAGhCX,EAAAxD,UAAA4D,oBAAWX,GACjB,OAAU5C,KAAK+D,QAAO,IAAInB,EAAM,mCAGtBO,EAAAxD,UAAA,UAAO,gBACjB,OAAUK,KAAKa,cAAchB,OAAM,mEA9BtCQ,EAAAA,sDAdQ2D,EAAAA,kBAEAtE,OAFT,GCOM2C,EAASC,EAEf2B,EAAA,WAmCE,SAAAA,EAAqBjC,EACTkC,EACAC,EACAC,EACAC,EACSC,EACAC,EACAC,EACAC,EACDC,GATC1E,KAAAgC,GAAAA,EAKAhC,KAAAsE,MAAAA,EACAtE,KAAAuE,QAAAA,EACAvE,KAAAwE,SAAAA,EACAxE,KAAAyE,UAAAA,EACDzE,KAAA0E,eAAAA,EAClB1E,KAAK2E,aAAe,IAAIC,EAAAA,gBAAgBR,GACxCpE,KAAK6E,uBAAyB,IAAID,EAAAA,gBAAgBT,GAClDnE,KAAK8E,aAAe,IAAIF,EAAAA,gBAAgBV,GACxClE,KAAK+E,2BAA6B,IAAIH,EAAAA,gBAAgBP,GACtDrE,KAAKgF,iBAAmB,IAAIJ,EAAAA,gBAAgBxE,kBA/CvC6D,EAAAhC,MAAP,SAAaC,EAAWwC,EAAgCO,GACtD,IAAM9C,EAAaD,EAAKC,WAClBmC,EAAQpC,EAAKY,eAAiBZ,EAAKY,cAAcwB,MAAQvC,EAAKK,IAAIF,EAAKY,cAAcwB,MAAMvB,MAAQ,GACnGwB,EAAUrC,EAAKY,eAAiBZ,EAAKY,cAAcyB,QAAUxC,EAAKK,IAAIF,EAAKY,cAAcyB,QAAQxB,MAAQ,GACzGyB,EAAWtC,EAAKY,eAAiBZ,EAAKY,cAAc0B,SAAWjC,EAAQH,IAAIF,EAAKY,cAAc0B,SAASzB,MAAQ,GAC/G0B,EAAYvC,EAAKY,eAAiBZ,EAAKY,cAAc2B,UAAY1C,EAAKE,MAAMC,EAAKY,cAAc2B,UAAU1B,MAAQ3C,UACvH,OAAO,IAAI6D,EAAK/B,EAAKF,GACLG,EAAW+B,KACX/B,EAAWgC,eAAiB9B,EAAOF,EAAWgC,gBAAgBe,MAAMrC,SAAWzC,UAC/E+B,EAAWiC,KACXjC,EAAWkC,mBACXC,EACAC,EACAC,EACAC,EACAC,IAGXT,EAAA7B,IAAP,SAAWF,EAAWwC,EAAgCO,GACpD,OAAI/C,EACKA,EAAKE,IAAI,SAAAY,GAAQ,OAAAiB,EAAKhC,MAAMe,EAAM0B,EAAgBO,KAElD7E,WA4BXF,OAAAC,eAAI8D,EAAAtE,UAAA,qBAAkB,KAAtB,WACE,OAAOK,KAAK+E,2BAA2BI,WAGzC,SAAuBC,GACrBpF,KAAK+E,2BAA2B9D,KAAKmE,oCAGvClF,OAAAC,eAAI8D,EAAAtE,UAAA,+BAA4B,KAAhC,WACE,OAAOK,KAAK+E,4DAGd7E,OAAAC,eAAI8D,EAAAtE,UAAA,OAAI,KAAR,WACE,OAAOK,KAAK8E,aAAaK,WAG3B,SAASjB,GACPlE,KAAK8E,aAAa7D,KAAKiD,oCAGzBhE,OAAAC,eAAI8D,EAAAtE,UAAA,iBAAc,KAAlB,WACE,OAAOK,KAAK8E,8CAGd5E,OAAAC,eAAI8D,EAAAtE,UAAA,OAAI,KAAR,WACE,OAAOK,KAAK2E,aAAaQ,WAG3B,SAASf,GACPpE,KAAK2E,aAAa1D,KAAKmD,oCAGzBlE,OAAAC,eAAI8D,EAAAtE,UAAA,iBAAc,KAAlB,WACE,OAAOK,KAAK2E,8CAGdzE,OAAAC,eAAI8D,EAAAtE,UAAA,iBAAc,KAAlB,WACE,OAAOK,KAAK6E,uBAAuBM,WAGrC,SAAmBhB,GACjBnE,KAAK6E,uBAAuB5D,KAAKkD,oCAGnCjE,OAAAC,eAAI8D,EAAAtE,UAAA,2BAAwB,KAA5B,WACE,OAAOK,KAAK6E,wDAGd3E,OAAAC,eAAI8D,EAAAtE,UAAA,WAAQ,KAAZ,WACE,OAAOK,KAAKgF,iBAAiBG,WAG/B,SAAaE,GACXrF,KAAKgF,iBAAiB/D,KAAKoE,oCAG7BnF,OAAAC,eAAI8D,EAAAtE,UAAA,qBAAkB,KAAtB,WACE,OAAOK,KAAKgF,kDAIdf,EAAAtE,UAAA2F,eAAA,WACE,OAAOtF,KAAK0E,eAAea,iBAAiBvF,MAAM,IAGpDiE,EAAAtE,UAAA6F,gBAAA,WACE,OAAOxF,KAAK0E,eAAea,iBAAiBvF,MAAM,IAGpDiE,EAAAtE,UAAA8F,sBAAA,WACE,OAAOzF,KAAK0E,eAAegB,8BAA8B1F,OAG3DiE,EAAAtE,UAAAgG,WAAA,SAAW7B,GACT9D,KAAKwE,SAASoB,KAAK9B,GACnB9D,KAAKmE,eAAiBL,EAAQpB,WAGhCuB,EAAAtE,UAAAkG,iBAAA,SAAiB/B,GACX9D,KAAK8F,oBACP9F,KAAK8F,mBAAmBC,MAAMjC,IAKlCG,EAAAtE,UAAAqG,QAAA,SAAQ9C,GACN,OAAOlD,KAAKsE,OAAStE,KAAKsE,MAAM2B,KAAK,SAAAC,GAAQ,OAAAA,EAAKlE,KAAQkB,KAG5De,EAAAtE,UAAAwG,iBAAA,WAAA,IAAAC,EAAApG,KACQ4D,EAAS,CACbyC,mBAA2C,EAAvBrG,KAAKwE,SAAS8B,OAAatG,KAAKwE,SAAS,GAAGxC,GAAK5B,WAEvE,OAAOJ,KAAK0E,eACA6B,aAAavG,KAAM4D,GACnBvC,KACVe,EAAAA,IAAI,SAAAoC,GAEF,OADA4B,EAAK5B,SAASgC,QAAQT,MAAMK,EAAK5B,SAAUA,GACpCA,MAKbP,EAAAtE,UAAA8G,kBAAA,SAAkBzE,GAChB,OAAOhC,KAAKwE,SAAWxE,KAAKwE,SAASkC,KAAK,SAAA5C,GAAW,OAAAA,EAAQ9B,KAAOA,IAAM5B,WAG5E6D,EAAAtE,UAAAgH,OAAA,WACE,OAAO3G,KAAK0E,eAAeiC,OAAO3G,OAGpCiE,EAAAtE,UAAAiH,YAAA,SAAYC,GAAZ,IAAAT,EAAApG,KACE,OAAOA,KAAK0E,eACAoC,cAAc9G,KAAM6G,GACpBxF,KACCe,EAAAA,IAAI,SAAA0B,GAEF,OADAsC,EAAKT,WAAW7B,GACTA,MAKxBG,EAAAtE,UAAAoH,cAAA,SAAcC,GACZ,IAAMC,EAAQjH,KAAKwE,SAAWxE,KAAKwE,SAAS0C,UAAU,SAAApD,GAAW,OAAAA,EAAQ9B,KAAOgF,EAAgBhF,MAAO,EAIvG,OAHa,EAATiF,GACFjH,KAAKwE,SAAS2C,OAAOF,EAAO,GAEvBD,GAGT/C,EAAAtE,UAAAkE,UAAA,SAAOC,GAAP,IAAAsC,EAAApG,KACE,OAAOA,KAAK0E,eACA0C,cAAcpH,KAAM8D,GACpBzC,KAAKe,EAAAA,IAAI,SAAAiF,GAAkB,OAAAjB,EAAKW,cAAcM,OAG5DpD,EAAAtE,UAAA2H,iBAAA,SAAiBtE,GAGf,OAFAhD,KAAKsE,MAAM6C,OAAO,EAAGnH,KAAKsE,MAAMgC,QAChCiB,MAAM5H,UAAUiG,KAAKG,MAAM/F,KAAKsE,MAAOtB,EAAKsB,OACrCtE,MAGTiE,EAAAtE,UAAA6H,QAAA,SAAQtB,GACDlG,KAAKgG,QAAQE,EAAKlE,KACrBhC,KAAKsE,MAAMsB,KAAKM,MApMtB,GCTAuB,EAAA,WAaE,SAAAA,EAAoBrE,EACA6B,EACApE,GAFAb,KAAAoD,KAAAA,EACApD,KAAAiF,kBAAAA,EACAjF,KAAAa,cAAAA,SAEpB4G,EAAA9H,UAAA+G,KAAA,SAAK1E,GAAL,IAAAoE,EAAApG,KACE,OAAOA,KAAKoD,KAAKO,IAAO3D,KAAK+D,QAAO,IAAI/B,GACvBX,KAAKe,EAAAA,IAAI,SAACF,GAAc,OAAA+B,EAAKhC,MAAMC,EAAKa,KAAMqD,EAAMA,EAAKnB,uBAG5EwC,EAAA9H,UAAA+D,QAAA,SAAQgE,GAAR,IAAAtB,EAAApG,KACE,OAAOA,KAAKoD,KAAKO,IAAI3D,KAAK+D,QAAS,CAAEH,OAAQ8D,IAC5BrG,KAAKe,EAAAA,IAAI,SAACF,GAAc,OAAA+B,EAAK7B,IAAIF,EAAKa,KAAMqD,EAAMA,EAAKnB,uBAG1EwC,EAAA9H,UAAAgI,gBAAA,WACE,OAAO3H,KAAK0D,QAAQ,CAAEkE,WAAY,UAGpCH,EAAA9H,UAAAkI,gBAAA,WACE,OAAO7H,KAAK0D,QAAQ,CAAEoE,WAAY,UAGpCL,EAAA9H,UAAAoI,eAAA,SAAe/F,GACb,OAAOhC,KAAK0D,QAAQ,CAAEsE,gBAAiBhG,KAGzCyF,EAAA9H,UAAAsI,eAAA,SAAeC,GACb,OAAOlI,KAAK0D,QAAQ,CAAEyE,YAAaD,KAGrCT,EAAA9H,UAAA4F,iBAAA,SAAiBvC,EAAYoB,GAC3B,OAAOpE,KAAKoD,KAAKgF,IAAOpI,KAAK+D,QAAO,IAAIf,EAAKhB,GAAE,cAAe,CAC5De,KAAM,CACJS,KAAM,aACNrB,WAAY,CACViC,KAAMA,MAGT/C,KAAKe,EAAAA,IAAI,SAACW,GAEX,OADAC,EAAKoB,KAAOrB,EAAKA,KAAKZ,WAAWiC,KAC1BpB,MAIXyE,EAAA9H,UAAA+F,8BAAA,SAA8B1C,GAC5B,GAA8B,EAA1BA,EAAKqB,mBAAwB,CAC/B,IAAMgE,EAA2C,EAAvBrF,EAAKwB,SAAS8B,OAAatD,EAAKwB,SAASxB,EAAKwB,SAAS8B,OAAS,GAAGtE,GAAK5B,UAClG,OAAOJ,KAAKoD,KAAKgF,IAAOpI,KAAK+D,QAAO,IAAIf,EAAKhB,GAAE,8BAA+B,CAAEe,KAAM,CAAEsF,kBAAmBA,KAC1FhH,KAAKe,EAAAA,IAAI,SAACW,GAET,OADAC,EAAKqB,mBAAqB,EACnBtB,EAAKuF,KAAKlD,SAGnC,OAAOmD,EAAAA,GAAG,IAIdd,EAAA9H,UAAA0D,OAAA,SAAOa,EAAcsE,EAAmBC,GAAxC,IAAArC,EAAApG,KACE,OAAOA,KAAKoD,KAAKE,KAAQtD,KAAK+D,QAAO,gBAAgB0E,EAAoB,CACvE1F,KAAM,CACJS,KAAM,OACNrB,WAAY,CACV+B,KAAMA,GAERpB,cAAe,CACbwB,MAAO,CACLvB,KAAMyF,EAAQpG,IAAI,SAAAc,GAAU,MAAA,CAAGM,KAAM,OAAQxB,GAAIkB,SAItD,CACDU,OAAQ,CACN8E,YAAa,GAAGD,KAEjBpH,KAAKe,EAAAA,IAAI,SAACqB,GAAkB,OAAAQ,EAAKhC,MAAMwB,EAASV,KAAMqD,EAAMA,EAAKnB,uBAGtEwC,EAAA9H,UAAAgH,OAAA,SAAO3D,GACL,OAAOhD,KAAKoD,KAAKgF,IAAOpI,KAAK+D,QAAO,IAAIf,EAAKhB,GAAM,CACjDe,KAAM,CACJS,KAAM,OACNrB,WAAY,CACV+B,KAAMlB,EAAKkB,SAGd7C,KAAKe,EAAAA,IAAI,SAACqB,GAEX,OADAT,EAAKkB,KAAOT,EAASV,KAAKZ,WAAW+B,KAC9BlB,MAIXyE,EAAA9H,UAAA6H,QAAA,SAAQxE,EAAYE,GAClB,OAAOlD,KAAKoD,KAAKE,KAAQtD,KAAK+D,QAAO,IAAIf,EAAKhB,GAAE,eAAgB,CAC9De,KAAM,CACJS,KAAM,aACNV,cAAe,CACboD,KAAM,CACJnD,KAAM,CACJS,KAAM,OACNxB,GAAIkB,QAKX7B,KAAKe,EAAAA,IAAI,SAACqB,GACX,IAAMkF,EAAU5G,EAAKE,MAAMwB,EAASV,KAAKD,cAAcoD,KAAKnD,MAE5D,OADAC,EAAKwE,QAAQmB,GACN3F,MAIXyE,EAAA9H,UAAAyH,cAAA,SAAcpE,EAAYc,GACxB,OAAO9D,KAAKiF,kBAAkBpB,UAAOb,EAAMc,IAG7C2D,EAAA9H,UAAA4G,aAAA,SAAavD,EAAYb,GACvB,OAAOnC,KAAKiF,kBAAkBvB,QAAQV,EAAMb,IAG9CsF,EAAA9H,UAAAmH,cAAA,SAAc9D,EAAYb,GACxB,OAAOnC,KAAKiF,kBAAkB5B,OAAOL,EAAMb,0BAGjCsF,EAAA9H,UAAA,UAAO,gBACjB,OAAUK,KAAKa,cAAchB,OAAM,mEA/HtCQ,EAAAA,sDAVQ2D,EAAAA,kBAKAb,SAHAzD,OAFT,GCOM2C,EAASC,EAEfsG,EAAA,WAaE,SAAAA,EAAqB5G,EACA6G,EACAC,EACTzE,EACA0E,EACQrE,GALC1E,KAAAgC,GAAAA,EACAhC,KAAA6I,YAAAA,EACA7I,KAAA8I,MAAAA,EAGD9I,KAAA0E,eAAAA,EAClB1E,KAAK+E,2BAA6B,IAAIH,EAAAA,gBAAgBP,GAAsB,GAC5ErE,KAAKgJ,kBAAoB,IAAIpE,EAAAA,gBAAgBmE,GAAa,UAlBrDH,EAAA3G,MAAP,SAAaC,EAAWwC,GACtB,IAAML,EAAqBnC,EAAKa,MAAQb,EAAKa,KAAKuF,KAAOpG,EAAKa,KAAKuF,KAAKjE,mBAAqB,EACvF0E,EAAY7G,EAAKa,MAAQb,EAAKa,KAAKuF,KAAOpG,EAAKa,KAAKuF,KAAKS,UAAY,EAC3E,OAAO,IAAIH,EAAG1G,EAAKa,KAAKf,GAAI,GAAI,GAAIqC,EAAoB0E,EAAWrE,IAmBrExE,OAAAC,eAAIyI,EAAAjJ,UAAA,qBAAkB,KAAtB,WACE,OAAOK,KAAK+E,2BAA2BI,WAGzC,SAAuBC,GACrBpF,KAAK+E,2BAA2B9D,KAAKmE,oCAGvClF,OAAAC,eAAIyI,EAAAjJ,UAAA,+BAA4B,KAAhC,WACE,OAAOK,KAAK+E,4DAGd7E,OAAAC,eAAIyI,EAAAjJ,UAAA,YAAS,KAAb,WACE,OAAOK,KAAKgJ,kBAAkB7D,uCAGhCjF,OAAAC,eAAIyI,EAAAjJ,UAAA,sBAAmB,KAAvB,WACE,OAAOK,KAAKgJ,mDAGdJ,EAAAjJ,UAAAsJ,iBAAA,WAAA,IAAA7C,EAAApG,KACE,OAAOA,KAAK0E,eAAeiD,kBAAkBtG,KAAKe,EAAAA,IAAI,SAAA0G,GAEpD,OADA1C,EAAK8C,SAASJ,GACPA,MAIXF,EAAAjJ,UAAAwJ,iBAAA,WAAA,IAAA/C,EAAApG,KACE,OAAOA,KAAK0E,eAAemD,kBAAkBxG,KAAKe,EAAAA,IAAI,SAAA0G,GAEpD,OADA1C,EAAK8C,SAASJ,GACPA,MAIXF,EAAAjJ,UAAAyJ,eAAA,WAAA,IAAAhD,EAAApG,KACE,OAAIA,KAAKqJ,cACArJ,KAAK0E,eAAeqD,eAAe/H,KAAKqJ,cAAcrH,IAAIX,KAAKe,EAAAA,IAAI,SAAA0G,GAExE,OADA1C,EAAK8C,SAASJ,GACPA,KAGFP,EAAAA,GAAG,KAIdK,EAAAjJ,UAAA2J,eAAA,SAAepB,GAAf,IAAA9B,EAAApG,KACE,OAAOA,KAAK0E,eAAeuD,eAAeC,GAAS7G,KAAKe,EAAAA,IAAI,SAAA0G,GAE1D,OADA1C,EAAK8C,SAASJ,GACPA,MAIXF,EAAAjJ,UAAA4J,cAAA,SAAc3G,GAAd,IAAAwD,EAAApG,KACE,OAAOA,KAAK0E,eAAegC,KAAK9D,GAAQvB,KAAKe,EAAAA,IAAI,SAAAY,GAE/C,OADAoD,EAAKoD,QAAQxG,GACNA,MAIX4F,EAAAjJ,UAAA8J,oBAAA,SAAoB7G,GAClB,IAAMI,EAAOhD,KAAK0J,aAAa9G,GAC/B,OAAIA,EACK2F,EAAAA,GAAGvF,GAEHhD,KAAKuJ,cAAc3G,IAI9BgG,EAAAjJ,UAAAgK,iBAAA,SAAiB9C,GAAjB,IAAAT,EAAApG,KACEA,KAAKyJ,oBAAoB5C,EAAWjE,QAC/BgH,UAAU,SAAA5G,GACLA,IACFA,EAAK2C,WAAWkB,GAChB7D,EAAK6C,iBAAiBgB,GACjBA,EAAW5D,YAAYmD,EAAKpE,MAC/BoE,EAAK/B,mBAAqB+B,EAAK/B,mBAAqB,EAC/CrB,EAAKoB,OACRpB,EAAKqB,mBAAqBrB,EAAKqB,mBAAqB,QAOlEuE,EAAAjJ,UAAA6J,QAAA,SAAQK,GACN,IAAK7J,KAAK8J,QAAQD,GAAU,CACrB7J,KAAKqJ,gBAAiBhH,EAAOrC,KAAKqJ,cAAclF,gBAAgB4F,QAAQF,EAAQ1F,kBACnFnE,KAAKqJ,cAAgBQ,GAGvB,IAAMG,EAAYhK,KAAK8I,MAAQ9I,KAAK8I,MAAM5B,UAAU,SAAAlE,GAAQ,OAAAA,EAAKhB,KAAO6H,EAAQ7H,MAAO,GACtE,EAAbgI,EACFhK,KAAK8I,MAAMkB,GAAaH,EAExB7J,KAAK8I,MAAMlD,KAAKiE,KAKtBjB,EAAAjJ,UAAA+J,aAAA,SAAa9G,GACX,OAAO5C,KAAK8I,MAAQ9I,KAAK8I,MAAMpC,KAAK,SAAA1D,GAAQ,OAAAJ,IAAWI,EAAKhB,KAAM5B,WAGpEwI,EAAAjJ,UAAAsK,SAAA,SAASjH,GAAT,IAAAoD,EAAApG,KACE,OAAKA,KAAKkK,cAAclH,GAOfuF,EAAAA,GAAGvF,GANHA,EAAKsC,iBACAjE,KAAK8I,EAAAA,QAAQ,SAACC,GAEb,OADAhE,EAAKiE,gBAAgBD,GACdhE,EAAKV,8BAA8B0E,OAO3DxB,EAAAjJ,UAAA2K,UAAA,SAAUtH,GAAV,IAAAoD,EAAApG,KACE,OAAIA,KAAKkK,cAAclH,GACdA,EAAKwC,kBACAnE,KAAKe,EAAAA,IAAI,SAAAmI,GAEP,OADAnE,EAAKoE,qBAAqBD,GACnBA,KAGdhC,EAAAA,GAAGvF,IAId4F,EAAAjJ,UAAA8K,WAAA,SAAWC,GAAX,IAAAtE,EAAApG,KACE,OAAOuI,EAAAA,GAAGmC,GAAcrJ,KACtBe,EAAAA,IAAI,SAAA0G,GAEF,OADAA,EAAM6B,QAAQ,SAAA3H,GAAQ,OAAAoD,EAAKkE,UAAUtH,KAC9B8F,MAKbF,EAAAjJ,UAAAiL,uBAAA,SAAuBC,GAAvB,IAAAzE,EAAApG,KACQ8K,EAAkB9K,KAAK6I,YAAYkC,OAAO,SAAA/H,GAAQ,OAAAA,EAAKhB,KAAO6I,EAAW7I,KAC/E,OAAOhC,KAAKyK,WAAWK,GAAiBzJ,KAAK8I,EAAAA,QAAQ,SAAArB,GAAS,OAAA1C,EAAK6D,SAASY,OAG9EjC,EAAAjJ,UAAAqL,eAAA,WACE,OAAiC,EAA1BhL,KAAK6I,YAAYvC,QAG1BsC,EAAAjJ,UAAAsL,WAAA,SAAW/G,EAAcsE,EAAmBC,GAA5C,IAAArC,EAAApG,KACE,OAAOA,KAAK0E,eAAerB,OAAOa,EAAMsE,EAASC,GACtBpH,KAAKe,EAAAA,IAAI,SAAAY,GAER,OADAoD,EAAKoD,QAAQxG,GACNA,MAIrC4F,EAAAjJ,UAAAuL,UAAA,SAAU1C,GACR,IAAMlE,EAAQkE,EAAQpG,IAAI,SAAAJ,GAAM,OAAA,IAAID,EAAKC,EAAI,MAIvCmJ,EAAO/K,UACPqE,EAAYzE,KAAKoL,SACvB,OAAO,IAAInH,EAAKkH,EACd/K,UACAA,WACA,EANsB,EAQtBkE,EAVgB,GACA,GAYhBG,EACAzE,KAAK0E,iBAITkE,EAAAjJ,UAAAiH,YAAA,SAAY5D,EAAYR,EAAiBC,GACvC,OAAOO,EAAK4D,YAAY,CACtBpE,QAASA,EACTC,YAAaA,EACb4I,gBAAiBrL,KAAKqL,mBAI1BzC,EAAAjJ,UAAA2L,WAAA,SAAWxH,GACT,OAAOA,GAAWA,EAAQb,YAAYjD,KAAKgC,KAG7C4G,EAAAjJ,UAAAyH,cAAA,SAActD,GACZ,GAAIA,EAAS,CACX,IAAMd,EAAOhD,KAAK0J,aAAa5F,EAAQlB,QACvC,OAAII,EACKA,EAAKa,UAAOC,GAEZyE,EAAAA,GAAGnI,WAGZ,OAAOmI,EAAAA,GAAGnI,YAIdwI,EAAAjJ,UAAA4L,UAAA,SAAUvI,EAAYE,GACpB,OAAOlD,KAAK0E,eAAe8C,QAAQxE,EAAME,IAGnC0F,EAAAjJ,UAAAuJ,kBAASJ,cACfA,EAAM6B,QAAQ,SAAA3H,GACZoD,EAAKoD,QAAQxG,GACTA,EAAKoB,OAASgC,EAAK8D,cAAclH,IACnCoD,EAAKyC,YAAYjD,KAAK5C,MAKpB4F,EAAAjJ,UAAAmK,iBAAQ0B,GACd,OAAOxL,KAAKyL,SAASD,KAAgBpL,WAG/BwI,EAAAjJ,UAAAuK,uBAAcsB,GACpB,OAAOxL,KAAK0L,eAAeF,KAAgBpL,WAGrCwI,EAAAjJ,UAAA8L,kBAASzI,GACf,OAAOhD,KAAK0J,aAAa1G,EAAKhB,KAGxB4G,EAAAjJ,UAAA+L,wBAAeF,GACrB,OAAOxL,KAAK6I,YAAc7I,KAAK6I,YAAYnC,KAAK,SAAA1D,GAAQ,OAAAwI,EAAWxJ,KAAOgB,EAAKhB,KAAM5B,WAG/EwI,EAAAjJ,UAAA0K,yBAAgBrH,GACjBhD,KAAKkK,cAAclH,IACtBhD,KAAK6I,YAAYjD,KAAK5C,IAIlB4F,EAAAjJ,UAAA6K,8BAAqBD,GAC3B,GAAIvK,KAAKkK,cAAcK,GAAa,CAClC,IAAMP,EAAYhK,KAAK6I,YAAc7I,KAAK6I,YAAY3B,UAAU,SAAAlE,GAAQ,OAAAA,EAAKhB,KAAOuI,EAAWvI,KAAM5B,UACrGJ,KAAK6I,YAAY1B,OAAO6C,EAAW,KAI/BpB,EAAAjJ,UAAA+F,uCAA8B1C,cACpC,OAAOA,EAAKyC,wBACApE,KAAKe,EAAAA,IAAI,SAAAuJ,GAEP,OADAvF,EAAK/B,mBAAqBuH,KAAKC,IAAIzF,EAAK/B,mBAAqBsH,EAAkB,GACxE3I,MAIf4F,EAAAjJ,UAAAyL,kBACN,OAAO,IAAIrJ,EAAK/B,KAAKgC,GAAI,OAjR7B,GCTA8J,EAAA,WAWE,SAAAA,EAAoB1I,EACAsB,EACA7D,GAFAb,KAAAoD,KAAAA,EACApD,KAAA0E,eAAAA,EACA1E,KAAAa,cAAAA,SAEpBiL,EAAAnM,UAAAoM,OAAA,WAAA,IAAA3F,EAAApG,KACE,OAAOA,KAAKoD,KAAKO,IAAI3D,KAAKgM,SAAS3K,KAAKe,EAAAA,IAAI,SAAA6J,GAAM,OAAArD,EAAG3G,MAAMgK,EAAI7F,EAAK1B,oBAGtEoH,EAAAnM,UAAAuM,gBAAA,SAAgBD,GACd,OAAOjM,KAAKoD,KAAKgF,IAAIpI,KAAKmM,SAAU,CAAEpJ,KAAM,CAAES,KAAM,WACnCnC,KAAKC,EAAAA,WAAW,WAAM,OAAA8K,EAAAA,UAAUhK,EAAAA,IAAI,WAAM,OAAA,+BAGjD0J,EAAAnM,UAAA,UAAO,gBACjB,OAAUK,KAAKa,cAAchB,OAAM,+DAGzBiM,EAAAnM,UAAA,WAAQ,gBAClB,OAAUK,KAAKgM,QAAO,8DArBzB3L,EAAAA,sDARQ2D,EAAAA,kBAKAyD,SAHA/H,OAFT,GCAA2M,EAAA,WASE,SAAAA,EAAoBxL,GAAAb,KAAAa,cAAAA,SAEpBwL,EAAA1M,UAAA2M,QAAA,SAAQ5K,GAKN,OAJA1B,KAAKuM,OAASC,EAAAA,QAAWxM,KAAKa,cAAcf,UAAW,CACrD2M,UAAU,EACV/E,MAAO,SAAShG,IAEX1B,KAAKuM,QAGdF,EAAA1M,UAAA+M,aAAA,WACE,OAAO1M,KAAKuM,SAAWnM,WAGzBiM,EAAA1M,UAAAgN,WAAA,WACM3M,KAAK0M,iBACP1M,KAAKuM,OAAOK,QACZ5M,KAAKuM,OAASnM,gCAtBnBC,EAAAA,sDAHQX,OADT,GCAAmN,EAAA,WAgBE,SAAAA,EAAoBC,EACAC,EACAlM,EACAC,GAHAd,KAAA8M,aAAAA,EACA9M,KAAA+M,aAAAA,EACA/M,KAAAa,cAAAA,EACAb,KAAAc,mBAAAA,EAClBd,KAAKgN,OAAQ,SAGfH,EAAAlN,UAAAsN,MAAA,SAAMvL,GACC1B,KAAKc,mBAAmBP,kBAC3BP,KAAKc,mBAAmBN,SAAWkB,IAIvCmL,EAAAlN,UAAAsM,GAAA,WAAA,IAAA7F,EAAApG,KAWE,OAVKA,KAAKkN,gBACRlN,KAAKmN,SAAWnN,KAAK8M,aACAf,SACA1K,KACCe,EAAAA,IAAI,SAAA6J,GAAM,OAAA7F,EAAKgH,kBAAkBnB,KACjCoB,EAAAA,cAAc,GACdC,EAAAA,WACAC,EAAAA,UAGjBvN,KAAKmN,SAAS9L,KAAKe,EAAAA,IAAI,SAAA6J,GAAM,OAAA7F,EAAKoH,cAAcvB,OAGzDY,EAAAlN,UAAAc,MAAA,WACET,KAAKc,mBAAmBL,QACxBT,KAAKmN,SAAW/M,UAChBJ,KAAKgN,OAAQ,GAGPH,EAAAlN,UAAAyN,2BAAkBnB,cAMxB,OALAjM,KAAKgN,OAAQ,EACbS,EAAAA,MAAM,EAAGzN,KAAKa,cAAcd,mBAAmBsB,KAC7CqM,EAAAA,UAAU,WAAM,OAAAtH,EAAK4G,SAEtBpD,UAAU,WAAM,OAAAxD,EAAK0G,aAAaZ,gBAAgBD,KAC5CA,GAGDY,EAAAlN,UAAAuN,uBACN,OAAOlN,KAAKmN,WAAa/M,WAGnByM,EAAAlN,UAAA6N,uBAAcvB,cACpB,IAAKjM,KAAK+M,aAAaL,eAAgB,CACrC,IAAMH,EAASvM,KAAK+M,aAAaT,QAAQtM,KAAKc,mBAAmBN,UACjE+L,EAAOoB,GAAG,cAAe,SAAA5K,GAAQ,OAAAqD,EAAKwH,kBAAkB7K,KACxDwJ,EAAOoB,GAAG,YAAa,SAAA5K,GAAQ,OAAAkJ,EAAGZ,gBAAkBtI,EAAKsI,kBAE3D,OAAOY,GAGDY,EAAAlN,UAAAiO,2BAAkB1L,GACxB,IAAM4B,EAAUvB,EAAQN,MAAMC,EAAKa,MACnC/C,KAAKiM,KAAKrC,UAAU,SAAAqC,GAAM,OAAAA,EAAGtC,iBAAiB7F,0BA/DjDzD,EAAAA,sDAHQyL,SADAO,SALA3M,SAGAY,OAJT,GCGM+B,EAASC,oCAMbuL,EAAAlO,UAAAmO,UAAA,SAAUhF,EAAeiF,GACvB,OAAIjF,IAAU1I,WAAuB,OAAV0I,EAClBA,EAAMkF,KAAK,SAAChL,EAAYiL,GAC7B,IAAM9J,EAAsBnB,EAAKmB,eAC3B+J,EAAsBD,EAAU9J,eACtC,OAAI9B,EAAO8B,GAAgBgK,SAASD,GAC3B,EACE7L,EAAO6L,GAAqBC,SAAShK,IACtC,EAED,IAIJ2E,uBAlBZsF,EAAAA,KAAIC,KAAA,CAAC,CACJnK,KAAM,qBCNRoK,EAAA,gCAwBSA,EAAAC,QAAP,WACE,MAAO,CACLC,SAAUF,EACVG,UAAW,CACT/O,EACAmO,EACAvN,EACA+L,EACA,CACEqC,QAASC,EAAAA,kBACTC,SAAUhO,EACViO,OAAO,GAET1L,EACAsE,EACAqE,EACAe,yBA5BPiC,EAAAA,SAAQT,KAAA,CAAC,CACRU,QAAS,CACPC,EAAAA,kBAEFC,aAAc,CACZpB,GAEFqB,QAAS,CACPrB,SApBJ","sourcesContent":["import { Injectable, Injector } from \"@angular/core\";\nimport { BabiliUrlConfiguration } from \"./url-configuration.types\";\n\n@Injectable()\nexport class BabiliConfiguration {\n\n  private url: BabiliUrlConfiguration;\n\n  init(apiUrl: string, socketUrl: string, aliveIntervalInMs?: number) {\n    this.url = {\n      apiUrl: apiUrl,\n      socketUrl: socketUrl,\n      aliveIntervalInMs: aliveIntervalInMs\n    };\n  }\n\n  get apiUrl(): string {\n    return this.url ? this.url.apiUrl : undefined;\n  }\n\n  get socketUrl(): string {\n    return this.url ? this.url.socketUrl : undefined;\n  }\n\n  get aliveIntervalInMs(): number {\n    return this.url ? this.url.aliveIntervalInMs : 30000;\n  }\n}\n","import { Injectable } from \"@angular/core\";\n\n@Injectable()\nexport class TokenConfiguration {\n  public apiToken: string;\n\n  constructor() {}\n\n  isApiTokenSet(): boolean {\n    return this.apiToken !== undefined && this.apiToken !== null && this.apiToken !== \"\";\n  }\n\n  clear() {\n    this.apiToken = undefined;\n  }\n\n}\n","export class NotAuthorizedError {\n  constructor(readonly error: any) {}\n}\n","import { HttpErrorResponse, HttpEvent, HttpHandler, HttpInterceptor, HttpRequest } from \"@angular/common/http\";\nimport { Injectable } from \"@angular/core\";\nimport { BabiliConfiguration } from \"../configuration/babili.configuration\";\nimport { Observable, throwError } from \"rxjs\";\nimport { catchError } from \"rxjs/operators\";\nimport { TokenConfiguration } from \"./../configuration/token-configuration.types\";\nimport { NotAuthorizedError } from \"./not-authorized-error\";\n\n@Injectable()\nexport class HttpAuthenticationInterceptor implements HttpInterceptor {\n\n  constructor(private configuration: BabiliConfiguration,\n              private tokenConfiguration: TokenConfiguration) {}\n\n  intercept(request: HttpRequest<any>, next: HttpHandler): Observable<HttpEvent<any>> {\n    if (this.shouldAddHeaderTo(request)) {\n      return next.handle(this.addHeaderTo(request, this.tokenConfiguration.apiToken))\n                 .pipe(catchError(error => {\n                   if (error instanceof HttpErrorResponse && error.status === 401) {\n                     return throwError(new NotAuthorizedError(error));\n                   } else {\n                     return throwError(error);\n                   }\n                 }));\n    } else {\n      return next.handle(request);\n    }\n  }\n\n  private addHeaderTo(request: HttpRequest<any>, token: string): HttpRequest<any> {\n    return request.clone({\n      headers: request.headers.set(\"Authorization\", `Bearer ${token}`)\n    });\n  }\n\n  private shouldAddHeaderTo(request: HttpRequest<any>): boolean {\n    return request.url.startsWith(this.configuration.apiUrl);\n  }\n}\n","export class User {\n  static build(json: any): User {\n    if (json) {\n      return new User(json.id, json.attributes ? json.attributes.status : undefined);\n    } else {\n      return undefined;\n    }\n  }\n\n  static map(json: any): User[] {\n    if (json) {\n      return json.map(User.build);\n    } else {\n      return undefined;\n    }\n  }\n\n  constructor(readonly id: string,\n              readonly status: string) {}\n}\n","import * as momentLoaded from \"moment\";\nconst moment = momentLoaded;\n\nimport { User } from \"../user/user.types\";\n\nexport class Message {\n\n  static build(json: any): Message {\n    const attributes = json.attributes;\n    return new Message(json.id,\n                        attributes.content,\n                        attributes.contentType,\n                        moment(attributes.createdAt).toDate(),\n                        json.relationships.sender ? User.build(json.relationships.sender.data) : undefined,\n                        json.relationships.room.data.id);\n  }\n\n  static map(json: any): Message[] {\n    if (json) {\n      return json.map(Message.build);\n    } else {\n      return undefined;\n    }\n  }\n\n  constructor(readonly id: string,\n              readonly content: string,\n              readonly contentType: string,\n              readonly createdAt: Date,\n              readonly sender: User,\n              readonly roomId: string) {}\n\n  hasSenderId(userId: string) {\n    return this.sender && this.sender.id === userId;\n  }\n}\n","import { HttpClient } from \"@angular/common/http\";\nimport { Injectable } from \"@angular/core\";\nimport { BabiliConfiguration } from \"../configuration/babili.configuration\";\nimport { Observable } from \"rxjs\";\nimport { map } from \"rxjs/operators\";\nimport { Room } from \"../room/room.types\";\nimport { Message } from \"./message.types\";\n\nexport class NewMessage {\n  content: string;\n  contentType: string;\n  deviceSessionId: string;\n}\n\n@Injectable()\nexport class MessageRepository {\n\n  constructor(private http: HttpClient,\n              private configuration: BabiliConfiguration) {}\n\n  create(room: Room, attributes: NewMessage): Observable<Message> {\n    return this.http.post(this.messageUrl(room.id), {\n      data: {\n        type: \"message\",\n        attributes: attributes\n      }\n    }).pipe(map((response: any) => Message.build(response.data)));\n  }\n\n  findAll(room: Room, attributes: {[param: string]: string | string[]}): Observable<Message[]> {\n    return this.http.get(this.messageUrl(room.id), { params: attributes })\n                    .pipe(map((response: any) => Message.map(response.data)));\n  }\n\n  delete(room: Room, message: Message): Observable<Message> {\n    return this.http.delete(`${this.messageUrl(room.id)}/${message.id}`)\n                    .pipe(map(response => message));\n  }\n\n  private messageUrl(roomId: string) {\n    return `${this.roomUrl}/${roomId}/messages`;\n  }\n\n  private get roomUrl(): string {\n    return `${this.configuration.apiUrl}/user/rooms`;\n  }\n}\n","import * as momentLoaded from \"moment\";\nimport { BehaviorSubject, Observable } from \"rxjs\";\nimport { map } from \"rxjs/operators\";\nimport { Message } from \"../message/message.types\";\nimport { User } from \"../user/user.types\";\nimport { MessageRepository, NewMessage } from \"./../message/message.repository\";\nimport { RoomRepository } from \"./room.repository\";\nconst moment = momentLoaded;\n\nexport class Room {\n\n  static build(json: any, roomRepository: RoomRepository, messageRepository: MessageRepository): Room {\n    const attributes = json.attributes;\n    const users = json.relationships && json.relationships.users ? User.map(json.relationships.users.data) : [];\n    const senders = json.relationships && json.relationships.senders ? User.map(json.relationships.senders.data) : [];\n    const messages = json.relationships && json.relationships.messages ? Message.map(json.relationships.messages.data) : [];\n    const initiator = json.relationships && json.relationships.initiator ? User.build(json.relationships.initiator.data) : undefined;\n    return new Room(json.id,\n                    attributes.name,\n                    attributes.lastActivityAt ? moment(attributes.lastActivityAt).utc().toDate() : undefined,\n                    attributes.open,\n                    attributes.unreadMessageCount,\n                    users,\n                    senders,\n                    messages,\n                    initiator,\n                    roomRepository);\n  }\n\n  static map(json: any, roomRepository: RoomRepository, messageRepository: MessageRepository): Room[] {\n    if (json) {\n      return json.map(room => Room.build(room, roomRepository, messageRepository));\n    } else {\n      return undefined;\n    }\n  }\n\n  newMessageNotifier: (message: Message) => any;\n  private internalOpen: BehaviorSubject<boolean>;\n  private internalUnreadMessageCount: BehaviorSubject<number>;\n  private internalName: BehaviorSubject<string>;\n  private internalLastActivityAt: BehaviorSubject<Date>;\n  private internalImageUrl: BehaviorSubject<string>;\n\n  constructor(readonly id: string,\n              name: string,\n              lastActivityAt: Date,\n              open: boolean,\n              unreadMessageCount: number,\n              readonly users: User[],\n              readonly senders: User[],\n              readonly messages: Message[],\n              readonly initiator: User,\n              private roomRepository: RoomRepository) {\n    this.internalOpen = new BehaviorSubject(open);\n    this.internalLastActivityAt = new BehaviorSubject(lastActivityAt);\n    this.internalName = new BehaviorSubject(name);\n    this.internalUnreadMessageCount = new BehaviorSubject(unreadMessageCount);\n    this.internalImageUrl = new BehaviorSubject(undefined);\n  }\n\n  get unreadMessageCount(): number {\n    return this.internalUnreadMessageCount.value;\n  }\n\n  set unreadMessageCount(count: number) {\n    this.internalUnreadMessageCount.next(count);\n  }\n\n  get observableUnreadMessageCount(): BehaviorSubject<number> {\n    return this.internalUnreadMessageCount;\n  }\n\n  get name(): string {\n    return this.internalName.value;\n  }\n\n  set name(name: string) {\n    this.internalName.next(name);\n  }\n\n  get observableName(): BehaviorSubject<string> {\n    return this.internalName;\n  }\n\n  get open(): boolean {\n    return this.internalOpen.value;\n  }\n\n  set open(open: boolean) {\n    this.internalOpen.next(open);\n  }\n\n  get observableOpen(): BehaviorSubject<boolean> {\n    return this.internalOpen;\n  }\n\n  get lastActivityAt(): Date {\n    return this.internalLastActivityAt.value;\n  }\n\n  set lastActivityAt(lastActivityAt: Date) {\n    this.internalLastActivityAt.next(lastActivityAt);\n  }\n\n  get observableLastActivityAt(): BehaviorSubject<Date> {\n    return this.internalLastActivityAt;\n  }\n\n  get imageUrl(): string {\n    return this.internalImageUrl.value;\n  }\n\n  set imageUrl(imageUrl: string) {\n    this.internalImageUrl.next(imageUrl);\n  }\n\n  get observableImageUrl(): BehaviorSubject<string> {\n    return this.internalImageUrl;\n  }\n\n\n  openMembership(): Observable<Room> {\n    return this.roomRepository.updateMembership(this, true);\n  }\n\n  closeMembership(): Observable<Room> {\n    return this.roomRepository.updateMembership(this, false);\n  }\n\n  markAllMessagesAsRead(): Observable<number> {\n    return this.roomRepository.markAllReceivedMessagesAsRead(this);\n  }\n\n  addMessage(message: Message) {\n    this.messages.push(message);\n    this.lastActivityAt = message.createdAt;\n  }\n\n  notifyNewMessage(message: Message) {\n    if (this.newMessageNotifier) {\n      this.newMessageNotifier.apply(message);\n    }\n  }\n\n\n  hasUser(userId: string): boolean {\n    return this.users && this.users.some(user => user.id  === userId);\n  }\n\n  fetchMoreMessage(): Observable<Message[]> {\n    const params = {\n      firstSeenMessageId: this.messages.length > 0 ? this.messages[0].id : undefined\n    };\n    return this.roomRepository\n               .findMessages(this, params)\n               .pipe(\n      map(messages => {\n        this.messages.unshift.apply(this.messages, messages);\n        return messages;\n      })\n    );\n  }\n\n  findMessageWithId(id: string): Message {\n    return this.messages ? this.messages.find(message => message.id === id) : undefined;\n  }\n\n  update(): Observable<Room> {\n    return this.roomRepository.update(this);\n  }\n\n  sendMessage(newMessage: NewMessage): Observable<Message> {\n    return this.roomRepository\n               .createMessage(this, newMessage)\n               .pipe(\n                 map(message => {\n                   this.addMessage(message);\n                   return message;\n                 })\n               );\n  }\n\n  removeMessage(messageToDelete: Message): Message {\n    const index = this.messages ? this.messages.findIndex(message => message.id === messageToDelete.id) : -1;\n    if (index > -1) {\n      this.messages.splice(index, 1);\n    }\n    return messageToDelete;\n  }\n\n  delete(message: Message): Observable<Message> {\n    return this.roomRepository\n               .deleteMessage(this, message)\n               .pipe(map(deletedMessage => this.removeMessage(deletedMessage)));\n  }\n\n  replaceUsersWith(room: Room): Room {\n    this.users.splice(0, this.users.length);\n    Array.prototype.push.apply(this.users, room.users);\n    return this;\n  }\n\n  addUser(user: User) {\n    if (!this.hasUser(user.id)) {\n      this.users.push(user);\n    }\n  }\n}\n","import { HttpClient } from \"@angular/common/http\";\nimport { Injectable } from \"@angular/core\";\nimport { BabiliConfiguration } from \"../configuration/babili.configuration\";\nimport { Observable, of } from \"rxjs\";\nimport { map } from \"rxjs/operators\";\nimport { MessageRepository, NewMessage } from \"../message/message.repository\";\nimport { User } from \"../user/user.types\";\nimport { Message } from \"./../message/message.types\";\nimport { Room } from \"./room.types\";\n\n@Injectable()\nexport class RoomRepository {\n\n  constructor(private http: HttpClient,\n              private messageRepository: MessageRepository,\n              private configuration: BabiliConfiguration) {}\n\n  find(id: string): Observable<Room> {\n    return this.http.get(`${this.roomUrl}/${id}`)\n                    .pipe(map((json: any) => Room.build(json.data, this, this.messageRepository)));\n  }\n\n  findAll(query: {[param: string]: string | string[] }): Observable<Room[]> {\n    return this.http.get(this.roomUrl, { params: query })\n                    .pipe(map((json: any) => Room.map(json.data, this, this.messageRepository)));\n  }\n\n  findOpenedRooms(): Observable<Room[]> {\n    return this.findAll({ onlyOpened: \"true\" });\n  }\n\n  findClosedRooms(): Observable<Room[]> {\n    return this.findAll({ onlyClosed: \"true\" });\n  }\n\n  findRoomsAfter(id: string): Observable<Room[]> {\n    return this.findAll({ firstSeenRoomId: id });\n  }\n\n  findRoomsByIds(roomIds: string[]) {\n    return this.findAll({ \"roomIds[]\": roomIds });\n  }\n\n  updateMembership(room: Room, open: boolean): Observable<Room> {\n    return this.http.put(`${this.roomUrl}/${room.id}/membership`, {\n      data: {\n        type: \"membership\",\n        attributes: {\n          open: open\n        }\n      }\n    }).pipe(map((data: any) => {\n      room.open = data.data.attributes.open;\n      return room;\n    }));\n  }\n\n  markAllReceivedMessagesAsRead(room: Room): Observable<number> {\n    if (room.unreadMessageCount > 0) {\n      const lastReadMessageId = room.messages.length > 0 ? room.messages[room.messages.length - 1].id : undefined;\n      return this.http.put(`${this.roomUrl}/${room.id}/membership/unread-messages`, { data: { lastReadMessageId: lastReadMessageId } })\n                      .pipe(map((data: any) => {\n                        room.unreadMessageCount = 0;\n                        return data.meta.count;\n                      }));\n    } else {\n      return of(0);\n    }\n  }\n\n  create(name: string, userIds: string[], withoutDuplicate: boolean): Observable<Room> {\n    return this.http.post(`${this.roomUrl}?noDuplicate=${withoutDuplicate}`, {\n      data: {\n        type: \"room\",\n        attributes: {\n          name: name\n        },\n        relationships: {\n          users: {\n            data: userIds.map(userId => ({ type: \"user\", id: userId }) )\n          }\n        }\n      }\n    }, {\n      params: {\n        noDuplicate: `${withoutDuplicate}`\n      }\n    }).pipe(map((response: any) => Room.build(response.data, this, this.messageRepository)));\n  }\n\n  update(room: Room): Observable<Room> {\n    return this.http.put(`${this.roomUrl}/${room.id}`, {\n      data: {\n        type: \"room\",\n        attributes: {\n          name: room.name\n        }\n      }\n    }).pipe(map((response: any) => {\n      room.name = response.data.attributes.name;\n      return room;\n    }));\n  }\n\n  addUser(room: Room, userId: string): Observable<Room> {\n    return this.http.post(`${this.roomUrl}/${room.id}/memberships`, {\n      data: {\n        type: \"membership\",\n        relationships: {\n          user: {\n            data: {\n              type: \"user\",\n              id: userId\n            }\n          }\n        }\n      }\n    }).pipe(map((response: any) => {\n      const newUser = User.build(response.data.relationships.user.data);\n      room.addUser(newUser);\n      return room;\n    }));\n  }\n\n  deleteMessage(room: Room, message: Message): Observable<Message> {\n    return this.messageRepository.delete(room, message);\n  }\n\n  findMessages(room: Room, attributes: {[param: string]: string | string[]}): Observable<Message[]> {\n    return this.messageRepository.findAll(room, attributes);\n  }\n\n  createMessage(room: Room, attributes: NewMessage): Observable<Message> {\n    return this.messageRepository.create(room, attributes);\n  }\n\n  private get roomUrl(): string {\n    return `${this.configuration.apiUrl}/user/rooms`;\n  }\n}\n","import * as momentLoaded from \"moment\";\nimport { BehaviorSubject, Observable, of } from \"rxjs\";\nimport { flatMap, map } from \"rxjs/operators\";\nimport { Room } from \"../room/room.types\";\nimport { User } from \"../user/user.types\";\nimport { Message } from \"./../message/message.types\";\nimport { RoomRepository } from \"./../room/room.repository\";\nconst moment = momentLoaded;\n\nexport class Me {\n\n  static build(json: any, roomRepository: RoomRepository): Me {\n    const unreadMessageCount = json.data && json.data.meta ? json.data.meta.unreadMessageCount : 0;\n    const roomCount = json.data && json.data.meta ? json.data.meta.roomCount : 0;\n    return new Me(json.data.id, [], [], unreadMessageCount, roomCount, roomRepository);\n  }\n\n  public deviceSessionId: string;\n  private internalUnreadMessageCount: BehaviorSubject<number>;\n  private internalRoomCount: BehaviorSubject<number>;\n  private firstSeenRoom: Room;\n\n  constructor(readonly id: string,\n              readonly openedRooms: Room[],\n              readonly rooms: Room[],\n              unreadMessageCount: number,\n              roomCount: number,\n              private roomRepository: RoomRepository) {\n    this.internalUnreadMessageCount = new BehaviorSubject(unreadMessageCount || 0);\n    this.internalRoomCount = new BehaviorSubject(roomCount || 0);\n  }\n\n\n  get unreadMessageCount(): number {\n    return this.internalUnreadMessageCount.value;\n  }\n\n  set unreadMessageCount(count: number) {\n    this.internalUnreadMessageCount.next(count);\n  }\n\n  get observableUnreadMessageCount(): BehaviorSubject<number> {\n    return this.internalUnreadMessageCount;\n  }\n\n  get roomCount(): number {\n    return this.internalRoomCount.value;\n  }\n\n  get observableRoomCount(): BehaviorSubject<number> {\n    return this.internalRoomCount;\n  }\n\n  fetchOpenedRooms(): Observable<Room[]> {\n    return this.roomRepository.findOpenedRooms().pipe(map(rooms => {\n      this.addRooms(rooms);\n      return rooms;\n    }));\n  }\n\n  fetchClosedRooms(): Observable<Room[]> {\n    return this.roomRepository.findClosedRooms().pipe(map(rooms => {\n      this.addRooms(rooms);\n      return rooms;\n    }));\n  }\n\n  fetchMoreRooms(): Observable<Room[]> {\n    if (this.firstSeenRoom) {\n      return this.roomRepository.findRoomsAfter(this.firstSeenRoom.id).pipe(map(rooms => {\n        this.addRooms(rooms);\n        return rooms;\n      }));\n    } else {\n      return of([]);\n    }\n  }\n\n  fetchRoomsById(roomIds: string[]): Observable<Room[]> {\n    return this.roomRepository.findRoomsByIds(roomIds).pipe(map(rooms => {\n      this.addRooms(rooms);\n      return rooms;\n    }));\n  }\n\n  fetchRoomById(roomId: string): Observable<Room> {\n    return this.roomRepository.find(roomId).pipe(map(room => {\n      this.addRoom(room);\n      return room;\n    }));\n  }\n\n  findOrFetchRoomById(roomId: string): Observable<Room> {\n    const room = this.findRoomById(roomId);\n    if (roomId) {\n      return of(room);\n    } else {\n      return this.fetchRoomById(roomId);\n    }\n  }\n\n  handleNewMessage(newMessage: Message) {\n    this.findOrFetchRoomById(newMessage.roomId)\n        .subscribe(room => {\n          if (room) {\n            room.addMessage(newMessage);\n            room.notifyNewMessage(newMessage);\n            if (!newMessage.hasSenderId(this.id)) {\n              this.unreadMessageCount = this.unreadMessageCount + 1;\n              if (!room.open) {\n                room.unreadMessageCount = room.unreadMessageCount + 1;\n              }\n            }\n          }\n        });\n  }\n\n  addRoom(newRoom: Room) {\n    if (!this.hasRoom(newRoom)) {\n      if (!this.firstSeenRoom || moment(this.firstSeenRoom.lastActivityAt).isAfter(newRoom.lastActivityAt)) {\n        this.firstSeenRoom = newRoom;\n      }\n\n      const roomIndex = this.rooms ? this.rooms.findIndex(room => room.id === newRoom.id) : -1;\n      if (roomIndex > -1) {\n        this.rooms[roomIndex] = newRoom;\n      } else {\n        this.rooms.push(newRoom);\n      }\n    }\n  }\n\n  findRoomById(roomId: string): Room {\n    return this.rooms ? this.rooms.find(room => roomId === room.id) : undefined;\n  }\n\n  openRoom(room: Room): Observable<Room> {\n    if (!this.hasRoomOpened(room)) {\n      return room.openMembership()\n                 .pipe(flatMap((openedRoom: Room) => {\n                   this.addToOpenedRoom(openedRoom);\n                   return this.markAllReceivedMessagesAsRead(openedRoom);\n                 }));\n    } else {\n      return of(room);\n    }\n  }\n\n  closeRoom(room: Room): Observable<Room> {\n    if (this.hasRoomOpened(room)) {\n      return room.closeMembership()\n                 .pipe(map(closedRoom => {\n                    this.removeFromOpenedRoom(closedRoom);\n                    return closedRoom;\n                  }));\n    } else {\n      return of(room);\n    }\n  }\n\n  closeRooms(roomsToClose: Room[]): Observable<Room[]> {\n    return of(roomsToClose).pipe(\n      map(rooms => {\n        rooms.forEach(room => this.closeRoom(room));\n        return rooms;\n      })\n    );\n  }\n\n  openRoomAndCloseOthers(roomToOpen: Room): Observable<Room> {\n    const roomsToBeClosed = this.openedRooms.filter(room => room.id !== roomToOpen.id);\n    return this.closeRooms(roomsToBeClosed).pipe(flatMap(rooms => this.openRoom(roomToOpen)));\n  }\n\n  hasOpenedRooms(): boolean {\n    return this.openedRooms.length > 0;\n  }\n\n  createRoom(name: string, userIds: string[], withoutDuplicate: boolean): Observable<Room> {\n    return this.roomRepository.create(name, userIds, withoutDuplicate)\n                              .pipe(map(room => {\n                                this.addRoom(room);\n                                return room;\n                              }));\n  }\n\n  buildRoom(userIds: string[]): Room {\n    const users = userIds.map(id => new User(id, \"\"));\n    const noSenders = [];\n    const noMessage = [];\n    const noMessageUnread = 0;\n    const noId = undefined;\n    const initiator = this.toUser();\n    return new Room(noId,\n      undefined,\n      undefined,\n      true,\n      noMessageUnread,\n      users,\n      noSenders,\n      noMessage,\n      initiator,\n      this.roomRepository\n     );\n  }\n\n  sendMessage(room: Room, content: string, contentType: string): Observable<Message> {\n    return room.sendMessage({\n      content: content,\n      contentType: contentType,\n      deviceSessionId: this.deviceSessionId\n    });\n  }\n\n  isSentByMe(message: Message) {\n    return message && message.hasSenderId(this.id);\n  }\n\n  deleteMessage(message: Message): Observable<Message> {\n    if (message) {\n      const room = this.findRoomById(message.roomId);\n      if (room) {\n        return room.delete(message);\n      } else {\n        return of(undefined);\n      }\n    } else {\n      return of(undefined);\n    }\n  }\n\n  addUserTo(room: Room, userId: string): Observable<Room> {\n    return this.roomRepository.addUser(room, userId);\n  }\n\n  private addRooms(rooms: Room[]) {\n    rooms.forEach(room => {\n      this.addRoom(room);\n      if (room.open && !this.hasRoomOpened(room)) {\n        this.openedRooms.push(room);\n      }\n    });\n  }\n\n  private hasRoom(roomToFind: Room): boolean {\n    return this.findRoom(roomToFind) !== undefined;\n  }\n\n  private hasRoomOpened(roomToFind: Room): boolean {\n    return this.findRoomOpened(roomToFind) !== undefined;\n  }\n\n  private findRoom(room: Room): Room {\n    return this.findRoomById(room.id);\n  }\n\n  private findRoomOpened(roomToFind: Room): Room {\n    return this.openedRooms ? this.openedRooms.find(room => roomToFind.id === room.id) : undefined;\n  }\n\n  private addToOpenedRoom(room: Room) {\n    if (!this.hasRoomOpened(room)) {\n      this.openedRooms.push(room);\n    }\n  }\n\n  private removeFromOpenedRoom(closedRoom: Room) {\n    if (this.hasRoomOpened(closedRoom)) {\n      const roomIndex = this.openedRooms ? this.openedRooms.findIndex(room => room.id === closedRoom.id) : undefined;\n      this.openedRooms.splice(roomIndex, 1);\n    }\n  }\n\n  private markAllReceivedMessagesAsRead(room: Room): Observable<Room> {\n    return room.markAllMessagesAsRead()\n               .pipe(map(readMessageCount => {\n                  this.unreadMessageCount = Math.max(this.unreadMessageCount - readMessageCount, 0);\n                  return room;\n                }));\n  }\n\n  private toUser(): User {\n    return new User(this.id, \"\");\n  }\n}\n","import { HttpClient } from \"@angular/common/http\";\nimport { Injectable } from \"@angular/core\";\nimport { BabiliConfiguration } from \"../configuration/babili.configuration\";\nimport { empty, Observable } from \"rxjs\";\nimport { catchError, map } from \"rxjs/operators\";\nimport { RoomRepository } from \"./../room/room.repository\";\nimport { Me } from \"./me.types\";\n\n@Injectable()\nexport class MeRepository {\n\n  constructor(private http: HttpClient,\n              private roomRepository: RoomRepository,\n              private configuration: BabiliConfiguration) {}\n\n  findMe(): Observable<Me> {\n    return this.http.get(this.userUrl).pipe(map(me => Me.build(me, this.roomRepository)));\n  }\n\n  updateAliveness(me: Me): Observable<void> {\n    return this.http.put(this.aliveUrl, { data: { type: \"alive\" }})\n                    .pipe(catchError(() => empty()), map(() => null));\n  }\n\n  private get userUrl(): string {\n    return `${this.configuration.apiUrl}/user`;\n  }\n\n  private get aliveUrl(): string {\n    return `${this.userUrl}/alive`;\n  }\n}\n\n","import { Injectable } from \"@angular/core\";\nimport { BabiliConfiguration } from \"../configuration/babili.configuration\";\nimport * as io from \"socket.io-client\";\n\n@Injectable()\nexport class BootstrapSocket {\n\n  private socket: SocketIOClient.Socket;\n\n  constructor(private configuration: BabiliConfiguration) {}\n\n  connect(token: string): SocketIOClient.Socket {\n    this.socket = io.connect(this.configuration.socketUrl, {\n      forceNew: true,\n      query: `token=${token}`\n    });\n    return this.socket;\n  }\n\n  socketExists(): boolean {\n    return this.socket !== undefined;\n  }\n\n  disconnect() {\n    if (this.socketExists()) {\n      this.socket.close();\n      this.socket = undefined;\n    }\n  }\n}\n","import { Injectable } from \"@angular/core\";\nimport { BabiliConfiguration } from \"../configuration/babili.configuration\";\nimport { Observable, timer } from \"rxjs\";\nimport { map, publishReplay, refCount, share, takeWhile } from \"rxjs/operators\";\nimport { TokenConfiguration } from \"./../configuration/token-configuration.types\";\nimport { Message } from \"./../message/message.types\";\nimport { BootstrapSocket } from \"./../socket/bootstrap.socket\";\nimport { MeRepository } from \"./me.repository\";\nimport { Me } from \"./me.types\";\n\n@Injectable()\nexport class MeService {\n\n  private cachedMe: Observable<Me>;\n  private alive: boolean;\n\n  constructor(private meRepository: MeRepository,\n              private socketClient: BootstrapSocket,\n              private configuration: BabiliConfiguration,\n              private tokenConfiguration: TokenConfiguration) {\n    this.alive = false;\n  }\n\n  setup(token: string): void {\n    if (!this.tokenConfiguration.isApiTokenSet()) {\n      this.tokenConfiguration.apiToken = token;\n    }\n  }\n\n  me(): Observable<Me> {\n    if (!this.hasCachedMe()) {\n      this.cachedMe = this.meRepository\n                          .findMe()\n                          .pipe(\n                            map(me => this.scheduleAliveness(me)),\n                            publishReplay(1),\n                            refCount(),\n                            share()\n                          );\n    }\n    return this.cachedMe.pipe(map(me => this.connectSocket(me)));\n  }\n\n  clear() {\n    this.tokenConfiguration.clear();\n    this.cachedMe = undefined;\n    this.alive = false;\n  }\n\n  private scheduleAliveness(me: Me): Me {\n    this.alive = true;\n    timer(0, this.configuration.aliveIntervalInMs).pipe(\n      takeWhile(() => this.alive)\n    )\n    .subscribe(() => this.meRepository.updateAliveness(me));\n    return me;\n  }\n\n  private hasCachedMe(): boolean {\n    return this.cachedMe !== undefined;\n  }\n\n  private connectSocket(me: Me): Me {\n    if (!this.socketClient.socketExists()) {\n      const socket = this.socketClient.connect(this.tokenConfiguration.apiToken);\n      socket.on(\"new message\", data => this.receiveNewMessage(data));\n      socket.on(\"connected\", data => me.deviceSessionId = data.deviceSessionId);\n    }\n    return me;\n  }\n\n  private receiveNewMessage(json: any) {\n    const message = Message.build(json.data);\n    this.me().subscribe(me => me.handleNewMessage(message));\n  }\n}\n","import { Pipe, PipeTransform } from \"@angular/core\";\nimport * as momentLoaded from \"moment\";\nimport { Room } from \"../room/room.types\";\nconst moment = momentLoaded;\n\n@Pipe({\n  name: \"sortRooms\"\n})\nexport class SortRoomPipe  implements PipeTransform {\n  transform(rooms: Room[], field: string): any[] {\n    if (rooms !== undefined && rooms !== null) {\n      return rooms.sort((room: Room, otherRoom: Room) => {\n        const lastActivityAt      = room.lastActivityAt;\n        const otherLastActivityAt = otherRoom.lastActivityAt;\n        if (moment(lastActivityAt).isBefore(otherLastActivityAt)) {\n          return 1;\n        } else if (moment(otherLastActivityAt).isBefore(lastActivityAt)) {\n          return -1;\n        } else {\n          return 0;\n        }\n      });\n    } else {\n      return rooms;\n    }\n  }\n}\n","import { HttpClientModule, HTTP_INTERCEPTORS } from \"@angular/common/http\";\nimport { ModuleWithProviders, NgModule } from \"@angular/core\";\nimport { BabiliConfiguration } from \"./configuration/babili.configuration\";\nimport { HttpAuthenticationInterceptor } from \"./authentication/http-authentication-interceptor\";\nimport { TokenConfiguration } from \"./configuration/token-configuration.types\";\nimport { MeRepository } from \"./me/me.repository\";\nimport { MeService } from \"./me/me.service\";\nimport { MessageRepository } from \"./message/message.repository\";\nimport { SortRoomPipe } from \"./pipe/sort-room\";\nimport { RoomRepository } from \"./room/room.repository\";\nimport { BootstrapSocket } from \"./socket/bootstrap.socket\";\n\n@NgModule({\n  imports: [\n    HttpClientModule\n  ],\n  declarations: [\n    SortRoomPipe\n  ],\n  exports: [\n    SortRoomPipe\n  ]\n })\nexport class BabiliModule {\n  static forRoot(): ModuleWithProviders {\n    return {\n      ngModule: BabiliModule,\n      providers: [\n        BabiliConfiguration,\n        SortRoomPipe,\n        TokenConfiguration,\n        BootstrapSocket,\n        {\n          provide: HTTP_INTERCEPTORS,\n          useClass: HttpAuthenticationInterceptor,\n          multi: true\n        },\n        MessageRepository,\n        RoomRepository,\n        MeRepository,\n        MeService\n      ]\n    };\n  }\n}\n"]}