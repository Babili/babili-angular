{"version":3,"sources":["ng://@babili.io/angular/configuration/token-configuration.types.ts","ng://@babili.io/angular/configuration/url-configuration.types.ts","ng://@babili.io/angular/authentication/not-authorized-error.ts","ng://@babili.io/angular/authentication/http-authentication-interceptor.ts","ng://@babili.io/angular/user/user.types.ts","ng://@babili.io/angular/message/message.types.ts","ng://@babili.io/angular/message/message.repository.ts","ng://@babili.io/angular/room/room.types.ts","ng://@babili.io/angular/room/room.repository.ts","ng://@babili.io/angular/me/me.types.ts","ng://@babili.io/angular/me/me.repository.ts","ng://@babili.io/angular/socket/bootstrap.socket.ts","ng://@babili.io/angular/me/me.service.ts","ng://@babili.io/angular/pipe/sort-room.ts","ng://@babili.io/angular/babili.module.ts"],"names":["TokenConfiguration","prototype","isApiTokenSet","this","apiToken","undefined","clear","Injectable","URL_CONFIGURATION","InjectionToken","NotAuthorizedError","error","HttpAuthenticationInterceptor","urls","tokenConfiguration","intercept","request","next","shouldAddHeaderTo","handle","addHeaderTo","pipe","catchError","HttpErrorResponse","status","throwError","token","clone","headers","set","url","startsWith","apiUrl","Inject","args","User","id","build","json","attributes","map","moment","momentLoaded","Message","content","contentType","createdAt","sender","roomId","toDate","relationships","data","room","hasSenderId","userId","MessageRepository","http","configuration","roomUrl","create","post","messageUrl","type","response","findAll","get","params","delete","message","HttpClient","Room","name","lastActivityAt","open","unreadMessageCount","users","senders","messages","initiator","roomRepository","internalOpen","BehaviorSubject","internalLastActivityAt","internalName","internalUnreadMessageCount","internalImageUrl","messageRepository","utc","Object","defineProperty","value","count","imageUrl","openMembership","updateMembership","closeMembership","markAllMessagesAsRead","markAllReceivedMessagesAsRead","addMessage","push","notifyNewMessage","newMessageNotifier","apply","hasUser","some","user","fetchMoreMessage","_this","firstSeenMessageId","length","findMessages","unshift","findMessageWithId","find","update","sendMessage","newMessage","createMessage","removeMessage","messageToDelete","index","findIndex","splice","deleteMessage","deletedMessage","replaceUsersWith","Array","addUser","RoomRepository","query","findOpenedRooms","onlyOpened","findClosedRooms","onlyClosed","findRoomsAfter","firstSeenRoomId","findRoomsByIds","roomIds","roomIds[]","put","lastReadMessageId","meta","of","userIds","withoutDuplicate","noDuplicate","newUser","Me","openedRooms","rooms","roomCount","internalRoomCount","fetchOpenedRooms","addRooms","fetchClosedRooms","fetchMoreRooms","firstSeenRoom","fetchRoomsById","fetchRoomById","addRoom","findOrFetchRoomById","findRoomById","handleNewMessage","subscribe","newRoom","hasRoom","isAfter","roomIndex","openRoom","hasRoomOpened","flatMap","openedRoom","addToOpenedRoom","closeRoom","closedRoom","removeFromOpenedRoom","closeRooms","roomsToClose","forEach","openRoomAndCloseOthers","roomToOpen","roomsToBeClosed","filter","hasOpenedRooms","createRoom","buildRoom","noId","toUser","deviceSessionId","isSentByMe","addUserTo","roomToFind","findRoom","findRoomOpened","readMessageCount","Math","max","MeRepository","userUrl","aliveUrl","findMe","me","updateAliveness","empty","BootstrapSocket","connect","socket","io.connect","socketUrl","forceNew","socketExists","disconnect","close","MeService","meRepository","socketClient","alive","setup","hasCachedMe","cachedMe","scheduleAliveness","publishReplay","refCount","share","connectSocket","timer","aliveIntervalInMs","takeWhile","on","receiveNewMessage","SortRoomPipe","transform","field","sort","otherRoom","otherLastActivityAt","isBefore","Pipe","BabiliModule","forRoot","urlConfiguration","ngModule","providers","provide","useValue","HTTP_INTERCEPTORS","useClass","multi","NgModule","imports","HttpClientModule","declarations","exports"],"mappings":"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","sourcesContent":["import { Injectable } from \"@angular/core\";\n\n@Injectable()\nexport class TokenConfiguration {\n  public apiToken: string;\n\n  constructor() {}\n\n  isApiTokenSet(): boolean {\n    return this.apiToken !== undefined && this.apiToken !== null && this.apiToken !== \"\";\n  }\n\n  clear() {\n    this.apiToken = undefined;\n  }\n\n}\n","import { InjectionToken } from \"@angular/core\";\n\nexport const URL_CONFIGURATION = new InjectionToken<BabiliUrlConfiguration>(\"BabiliUrlConfiguration\");\n\nexport interface BabiliUrlConfiguration {\n  apiUrl: string;\n  socketUrl: string;\n  aliveIntervalInMs?: number;\n}\n","export class NotAuthorizedError {\n  constructor(readonly error: any) {}\n}\n","import { HttpErrorResponse, HttpEvent, HttpHandler, HttpInterceptor, HttpRequest } from \"@angular/common/http\";\nimport { Inject, Injectable } from \"@angular/core\";\nimport { Observable, throwError } from \"rxjs\";\nimport { catchError } from \"rxjs/operators\";\nimport { TokenConfiguration } from \"./../configuration/token-configuration.types\";\nimport { BabiliUrlConfiguration, URL_CONFIGURATION } from \"./../configuration/url-configuration.types\";\nimport { NotAuthorizedError } from \"./not-authorized-error\";\n\n@Injectable()\nexport class HttpAuthenticationInterceptor implements HttpInterceptor {\n\n  constructor(@Inject(URL_CONFIGURATION) private urls: BabiliUrlConfiguration,\n              private tokenConfiguration: TokenConfiguration) {}\n\n  intercept(request: HttpRequest<any>, next: HttpHandler): Observable<HttpEvent<any>> {\n    if (this.shouldAddHeaderTo(request)) {\n      return next.handle(this.addHeaderTo(request, this.tokenConfiguration.apiToken))\n                 .pipe(catchError(error => {\n                   if (error instanceof HttpErrorResponse && error.status === 401) {\n                     return throwError(new NotAuthorizedError(error));\n                   } else {\n                     return throwError(error);\n                   }\n                 }));\n    } else {\n      return next.handle(request);\n    }\n  }\n\n  private addHeaderTo(request: HttpRequest<any>, token: string): HttpRequest<any> {\n    return request.clone({\n      headers: request.headers.set(\"Authorization\", `Bearer ${token}`)\n    });\n  }\n\n  private shouldAddHeaderTo(request: HttpRequest<any>): boolean {\n    return request.url.startsWith(this.urls.apiUrl);\n  }\n}\n","export class User {\n  static build(json: any): User {\n    if (json) {\n      return new User(json.id, json.attributes ? json.attributes.status : undefined);\n    } else {\n      return undefined;\n    }\n  }\n\n  static map(json: any): User[] {\n    if (json) {\n      return json.map(User.build);\n    } else {\n      return undefined;\n    }\n  }\n\n  constructor(readonly id: string,\n              readonly status: string) {}\n}\n","import * as momentLoaded from \"moment\";\nconst moment = momentLoaded;\n\nimport { User } from \"../user/user.types\";\n\nexport class Message {\n\n  static build(json: any): Message {\n    const attributes = json.attributes;\n    return new Message(json.id,\n                        attributes.content,\n                        attributes.contentType,\n                        moment(attributes.createdAt).toDate(),\n                        json.relationships.sender ? User.build(json.relationships.sender.data) : undefined,\n                        json.relationships.room.data.id);\n  }\n\n  static map(json: any): Message[] {\n    if (json) {\n      return json.map(Message.build);\n    } else {\n      return undefined;\n    }\n  }\n\n  constructor(readonly id: string,\n              readonly content: string,\n              readonly contentType: string,\n              readonly createdAt: Date,\n              readonly sender: User,\n              readonly roomId: string) {}\n\n  hasSenderId(userId: string) {\n    return this.sender && this.sender.id === userId;\n  }\n}\n","import { HttpClient } from \"@angular/common/http\";\nimport { Inject, Injectable } from \"@angular/core\";\nimport { Observable } from \"rxjs\";\nimport { map } from \"rxjs/operators\";\nimport { BabiliUrlConfiguration, URL_CONFIGURATION } from \"../configuration/url-configuration.types\";\nimport { Room } from \"../room/room.types\";\nimport { Message } from \"./message.types\";\n\nexport class NewMessage {\n  content: string;\n  contentType: string;\n  deviceSessionId: string;\n}\n\n@Injectable()\nexport class MessageRepository {\n\n  private roomUrl: string;\n\n  constructor(private http: HttpClient,\n              @Inject(URL_CONFIGURATION) configuration: BabiliUrlConfiguration) {\n    this.roomUrl = `${configuration.apiUrl}/user/rooms`;\n  }\n\n  create(room: Room, attributes: NewMessage): Observable<Message> {\n    return this.http.post(this.messageUrl(room.id), {\n      data: {\n        type: \"message\",\n        attributes: attributes\n      }\n    }).pipe(map((response: any) => Message.build(response.data)));\n  }\n\n  findAll(room: Room, attributes: {[param: string]: string | string[]}): Observable<Message[]> {\n    return this.http.get(this.messageUrl(room.id), { params: attributes })\n                    .pipe(map((response: any) => Message.map(response.data)));\n  }\n\n  delete(room: Room, message: Message): Observable<Message> {\n    return this.http.delete(`${this.messageUrl(room.id)}/${message.id}`)\n                    .pipe(map(response => message));\n  }\n\n  private messageUrl(roomId: string) {\n    return `${this.roomUrl}/${roomId}/messages`;\n  }\n\n}\n","import * as momentLoaded from \"moment\";\nimport { BehaviorSubject, Observable } from \"rxjs\";\nimport { map } from \"rxjs/operators\";\nimport { Message } from \"../message/message.types\";\nimport { User } from \"../user/user.types\";\nimport { MessageRepository, NewMessage } from \"./../message/message.repository\";\nimport { RoomRepository } from \"./room.repository\";\nconst moment = momentLoaded;\n\nexport class Room {\n\n  static build(json: any, roomRepository: RoomRepository, messageRepository: MessageRepository): Room {\n    const attributes = json.attributes;\n    const users = json.relationships && json.relationships.users ? User.map(json.relationships.users.data) : [];\n    const senders = json.relationships && json.relationships.senders ? User.map(json.relationships.senders.data) : [];\n    const messages = json.relationships && json.relationships.messages ? Message.map(json.relationships.messages.data) : [];\n    const initiator = json.relationships && json.relationships.initiator ? User.build(json.relationships.initiator.data) : undefined;\n    return new Room(json.id,\n                    attributes.name,\n                    attributes.lastActivityAt ? moment(attributes.lastActivityAt).utc().toDate() : undefined,\n                    attributes.open,\n                    attributes.unreadMessageCount,\n                    users,\n                    senders,\n                    messages,\n                    initiator,\n                    roomRepository);\n  }\n\n  static map(json: any, roomRepository: RoomRepository, messageRepository: MessageRepository): Room[] {\n    if (json) {\n      return json.map(room => Room.build(room, roomRepository, messageRepository));\n    } else {\n      return undefined;\n    }\n  }\n\n  newMessageNotifier: (message: Message) => any;\n  private internalOpen: BehaviorSubject<boolean>;\n  private internalUnreadMessageCount: BehaviorSubject<number>;\n  private internalName: BehaviorSubject<string>;\n  private internalLastActivityAt: BehaviorSubject<Date>;\n  private internalImageUrl: BehaviorSubject<string>;\n\n  constructor(readonly id: string,\n              name: string,\n              lastActivityAt: Date,\n              open: boolean,\n              unreadMessageCount: number,\n              readonly users: User[],\n              readonly senders: User[],\n              readonly messages: Message[],\n              readonly initiator: User,\n              private roomRepository: RoomRepository) {\n    this.internalOpen = new BehaviorSubject(open);\n    this.internalLastActivityAt = new BehaviorSubject(lastActivityAt);\n    this.internalName = new BehaviorSubject(name);\n    this.internalUnreadMessageCount = new BehaviorSubject(unreadMessageCount);\n    this.internalImageUrl = new BehaviorSubject(undefined);\n  }\n\n  get unreadMessageCount(): number {\n    return this.internalUnreadMessageCount.value;\n  }\n\n  set unreadMessageCount(count: number) {\n    this.internalUnreadMessageCount.next(count);\n  }\n\n  get observableUnreadMessageCount(): BehaviorSubject<number> {\n    return this.internalUnreadMessageCount;\n  }\n\n  get name(): string {\n    return this.internalName.value;\n  }\n\n  set name(name: string) {\n    this.internalName.next(name);\n  }\n\n  get observableName(): BehaviorSubject<string> {\n    return this.internalName;\n  }\n\n  get open(): boolean {\n    return this.internalOpen.value;\n  }\n\n  set open(open: boolean) {\n    this.internalOpen.next(open);\n  }\n\n  get observableOpen(): BehaviorSubject<boolean> {\n    return this.internalOpen;\n  }\n\n  get lastActivityAt(): Date {\n    return this.internalLastActivityAt.value;\n  }\n\n  set lastActivityAt(lastActivityAt: Date) {\n    this.internalLastActivityAt.next(lastActivityAt);\n  }\n\n  get observableLastActivityAt(): BehaviorSubject<Date> {\n    return this.internalLastActivityAt;\n  }\n\n  get imageUrl(): string {\n    return this.internalImageUrl.value;\n  }\n\n  set imageUrl(imageUrl: string) {\n    this.internalImageUrl.next(imageUrl);\n  }\n\n  get observableImageUrl(): BehaviorSubject<string> {\n    return this.internalImageUrl;\n  }\n\n\n  openMembership(): Observable<Room> {\n    return this.roomRepository.updateMembership(this, true);\n  }\n\n  closeMembership(): Observable<Room> {\n    return this.roomRepository.updateMembership(this, false);\n  }\n\n  markAllMessagesAsRead(): Observable<number> {\n    return this.roomRepository.markAllReceivedMessagesAsRead(this);\n  }\n\n  addMessage(message: Message) {\n    this.messages.push(message);\n    this.lastActivityAt = message.createdAt;\n  }\n\n  notifyNewMessage(message: Message) {\n    if (this.newMessageNotifier) {\n      this.newMessageNotifier.apply(message);\n    }\n  }\n\n\n  hasUser(userId: string): boolean {\n    return this.users && this.users.some(user => user.id  === userId);\n  }\n\n  fetchMoreMessage(): Observable<Message[]> {\n    const params = {\n      firstSeenMessageId: this.messages.length > 0 ? this.messages[0].id : undefined\n    };\n    return this.roomRepository\n               .findMessages(this, params)\n               .pipe(\n      map(messages => {\n        this.messages.unshift.apply(this.messages, messages);\n        return messages;\n      })\n    );\n  }\n\n  findMessageWithId(id: string): Message {\n    return this.messages ? this.messages.find(message => message.id === id) : undefined;\n  }\n\n  update(): Observable<Room> {\n    return this.roomRepository.update(this);\n  }\n\n  sendMessage(newMessage: NewMessage): Observable<Message> {\n    return this.roomRepository\n               .createMessage(this, newMessage)\n               .pipe(\n                 map(message => {\n                   this.addMessage(message);\n                   return message;\n                 })\n               );\n  }\n\n  removeMessage(messageToDelete: Message): Message {\n    const index = this.messages ? this.messages.findIndex(message => message.id === messageToDelete.id) : -1;\n    if (index > -1) {\n      this.messages.splice(index, 1);\n    }\n    return messageToDelete;\n  }\n\n  delete(message: Message): Observable<Message> {\n    return this.roomRepository\n               .deleteMessage(this, message)\n               .pipe(map(deletedMessage => this.removeMessage(deletedMessage)));\n  }\n\n  replaceUsersWith(room: Room): Room {\n    this.users.splice(0, this.users.length);\n    Array.prototype.push.apply(this.users, room.users);\n    return this;\n  }\n\n  addUser(user: User) {\n    if (!this.hasUser(user.id)) {\n      this.users.push(user);\n    }\n  }\n}\n","import { HttpClient } from \"@angular/common/http\";\nimport { Inject, Injectable } from \"@angular/core\";\nimport { Observable, of } from \"rxjs\";\nimport { map } from \"rxjs/operators\";\nimport { BabiliUrlConfiguration, URL_CONFIGURATION } from \"../configuration/url-configuration.types\";\nimport { MessageRepository, NewMessage } from \"../message/message.repository\";\nimport { User } from \"../user/user.types\";\nimport { Message } from \"./../message/message.types\";\nimport { Room } from \"./room.types\";\n\n@Injectable()\nexport class RoomRepository {\n\n  private roomUrl: string;\n\n  constructor(private http: HttpClient,\n              private messageRepository: MessageRepository,\n              @Inject(URL_CONFIGURATION) configuration: BabiliUrlConfiguration) {\n    this.roomUrl = `${configuration.apiUrl}/user/rooms`;\n  }\n\n  find(id: string): Observable<Room> {\n    return this.http.get(`${this.roomUrl}/${id}`)\n                    .pipe(map((json: any) => Room.build(json.data, this, this.messageRepository)));\n  }\n\n  findAll(query: {[param: string]: string | string[] }): Observable<Room[]> {\n    return this.http.get(this.roomUrl, { params: query })\n                    .pipe(map((json: any) => Room.map(json.data, this, this.messageRepository)));\n  }\n\n  findOpenedRooms(): Observable<Room[]> {\n    return this.findAll({ onlyOpened: \"true\" });\n  }\n\n  findClosedRooms(): Observable<Room[]> {\n    return this.findAll({ onlyClosed: \"true\" });\n  }\n\n  findRoomsAfter(id: string): Observable<Room[]> {\n    return this.findAll({ firstSeenRoomId: id });\n  }\n\n  findRoomsByIds(roomIds: string[]) {\n    return this.findAll({ \"roomIds[]\": roomIds });\n  }\n\n  updateMembership(room: Room, open: boolean): Observable<Room> {\n    return this.http.put(`${this.roomUrl}/${room.id}/membership`, {\n      data: {\n        type: \"membership\",\n        attributes: {\n          open: open\n        }\n      }\n    }).pipe(map((data: any) => {\n      room.open = data.data.attributes.open;\n      return room;\n    }));\n  }\n\n  markAllReceivedMessagesAsRead(room: Room): Observable<number> {\n    if (room.unreadMessageCount > 0) {\n      const lastReadMessageId = room.messages.length > 0 ? room.messages[room.messages.length - 1].id : undefined;\n      return this.http.put(`${this.roomUrl}/${room.id}/membership/unread-messages`, { data: { lastReadMessageId: lastReadMessageId } })\n                      .pipe(map((data: any) => {\n                        room.unreadMessageCount = 0;\n                        return data.meta.count;\n                      }));\n    } else {\n      return of(0);\n    }\n  }\n\n  create(name: string, userIds: string[], withoutDuplicate: boolean): Observable<Room> {\n    return this.http.post(`${this.roomUrl}?noDuplicate=${withoutDuplicate}`, {\n      data: {\n        type: \"room\",\n        attributes: {\n          name: name\n        },\n        relationships: {\n          users: {\n            data: userIds.map(userId => ({ type: \"user\", id: userId }) )\n          }\n        }\n      }\n    }, {\n      params: {\n        noDuplicate: `${withoutDuplicate}`\n      }\n    }).pipe(map((response: any) => Room.build(response.data, this, this.messageRepository)));\n  }\n\n  update(room: Room): Observable<Room> {\n    return this.http.put(`${this.roomUrl}/${room.id}`, {\n      data: {\n        type: \"room\",\n        attributes: {\n          name: room.name\n        }\n      }\n    }).pipe(map((response: any) => {\n      room.name = response.data.attributes.name;\n      return room;\n    }));\n  }\n\n  addUser(room: Room, userId: string): Observable<Room> {\n    return this.http.post(`${this.roomUrl}/${room.id}/memberships`, {\n      data: {\n        type: \"membership\",\n        relationships: {\n          user: {\n            data: {\n              type: \"user\",\n              id: userId\n            }\n          }\n        }\n      }\n    }).pipe(map((response: any) => {\n      const newUser = User.build(response.data.relationships.user.data);\n      room.addUser(newUser);\n      return room;\n    }));\n  }\n\n  deleteMessage(room: Room, message: Message): Observable<Message> {\n    return this.messageRepository.delete(room, message);\n  }\n\n  findMessages(room: Room, attributes: {[param: string]: string | string[]}): Observable<Message[]> {\n    return this.messageRepository.findAll(room, attributes);\n  }\n\n  createMessage(room: Room, attributes: NewMessage): Observable<Message> {\n    return this.messageRepository.create(room, attributes);\n  }\n}\n","import * as momentLoaded from \"moment\";\nimport { BehaviorSubject, Observable, of } from \"rxjs\";\nimport { flatMap, map } from \"rxjs/operators\";\nimport { Room } from \"../room/room.types\";\nimport { User } from \"../user/user.types\";\nimport { Message } from \"./../message/message.types\";\nimport { RoomRepository } from \"./../room/room.repository\";\nconst moment = momentLoaded;\n\nexport class Me {\n\n  static build(json: any, roomRepository: RoomRepository): Me {\n    const unreadMessageCount = json.data && json.data.meta ? json.data.meta.unreadMessageCount : 0;\n    const roomCount = json.data && json.data.meta ? json.data.meta.roomCount : 0;\n    return new Me(json.data.id, [], [], unreadMessageCount, roomCount, roomRepository);\n  }\n\n  public deviceSessionId: string;\n  private internalUnreadMessageCount: BehaviorSubject<number>;\n  private internalRoomCount: BehaviorSubject<number>;\n  private firstSeenRoom: Room;\n\n  constructor(readonly id: string,\n              readonly openedRooms: Room[],\n              readonly rooms: Room[],\n              unreadMessageCount: number,\n              roomCount: number,\n              private roomRepository: RoomRepository) {\n    this.internalUnreadMessageCount = new BehaviorSubject(unreadMessageCount || 0);\n    this.internalRoomCount = new BehaviorSubject(roomCount || 0);\n  }\n\n\n  get unreadMessageCount(): number {\n    return this.internalUnreadMessageCount.value;\n  }\n\n  set unreadMessageCount(count: number) {\n    this.internalUnreadMessageCount.next(count);\n  }\n\n  get observableUnreadMessageCount(): BehaviorSubject<number> {\n    return this.internalUnreadMessageCount;\n  }\n\n  get roomCount(): number {\n    return this.internalRoomCount.value;\n  }\n\n  get observableRoomCount(): BehaviorSubject<number> {\n    return this.internalRoomCount;\n  }\n\n  fetchOpenedRooms(): Observable<Room[]> {\n    return this.roomRepository.findOpenedRooms().pipe(map(rooms => {\n      this.addRooms(rooms);\n      return rooms;\n    }));\n  }\n\n  fetchClosedRooms(): Observable<Room[]> {\n    return this.roomRepository.findClosedRooms().pipe(map(rooms => {\n      this.addRooms(rooms);\n      return rooms;\n    }));\n  }\n\n  fetchMoreRooms(): Observable<Room[]> {\n    if (this.firstSeenRoom) {\n      return this.roomRepository.findRoomsAfter(this.firstSeenRoom.id).pipe(map(rooms => {\n        this.addRooms(rooms);\n        return rooms;\n      }));\n    } else {\n      return of([]);\n    }\n  }\n\n  fetchRoomsById(roomIds: string[]): Observable<Room[]> {\n    return this.roomRepository.findRoomsByIds(roomIds).pipe(map(rooms => {\n      this.addRooms(rooms);\n      return rooms;\n    }));\n  }\n\n  fetchRoomById(roomId: string): Observable<Room> {\n    return this.roomRepository.find(roomId).pipe(map(room => {\n      this.addRoom(room);\n      return room;\n    }));\n  }\n\n  findOrFetchRoomById(roomId: string): Observable<Room> {\n    const room = this.findRoomById(roomId);\n    if (roomId) {\n      return of(room);\n    } else {\n      return this.fetchRoomById(roomId);\n    }\n  }\n\n  handleNewMessage(newMessage: Message) {\n    this.findOrFetchRoomById(newMessage.roomId)\n        .subscribe(room => {\n          if (room) {\n            room.addMessage(newMessage);\n            room.notifyNewMessage(newMessage);\n            if (!newMessage.hasSenderId(this.id)) {\n              this.unreadMessageCount = this.unreadMessageCount + 1;\n              if (!room.open) {\n                room.unreadMessageCount = room.unreadMessageCount + 1;\n              }\n            }\n          }\n        });\n  }\n\n  addRoom(newRoom: Room) {\n    if (!this.hasRoom(newRoom)) {\n      if (!this.firstSeenRoom || moment(this.firstSeenRoom.lastActivityAt).isAfter(newRoom.lastActivityAt)) {\n        this.firstSeenRoom = newRoom;\n      }\n\n      const roomIndex = this.rooms ? this.rooms.findIndex(room => room.id === newRoom.id) : -1;\n      if (roomIndex > -1) {\n        this.rooms[roomIndex] = newRoom;\n      } else {\n        this.rooms.push(newRoom);\n      }\n    }\n  }\n\n  findRoomById(roomId: string): Room {\n    return this.rooms ? this.rooms.find(room => roomId === room.id) : undefined;\n  }\n\n  openRoom(room: Room): Observable<Room> {\n    if (!this.hasRoomOpened(room)) {\n      return room.openMembership()\n                 .pipe(flatMap((openedRoom: Room) => {\n                   this.addToOpenedRoom(openedRoom);\n                   return this.markAllReceivedMessagesAsRead(openedRoom);\n                 }));\n    } else {\n      return of(room);\n    }\n  }\n\n  closeRoom(room: Room): Observable<Room> {\n    if (this.hasRoomOpened(room)) {\n      return room.closeMembership()\n                 .pipe(map(closedRoom => {\n                    this.removeFromOpenedRoom(closedRoom);\n                    return closedRoom;\n                  }));\n    } else {\n      return of(room);\n    }\n  }\n\n  closeRooms(roomsToClose: Room[]): Observable<Room[]> {\n    return of(roomsToClose).pipe(\n      map(rooms => {\n        rooms.forEach(room => this.closeRoom(room));\n        return rooms;\n      })\n    );\n  }\n\n  openRoomAndCloseOthers(roomToOpen: Room): Observable<Room> {\n    const roomsToBeClosed = this.openedRooms.filter(room => room.id !== roomToOpen.id);\n    return this.closeRooms(roomsToBeClosed).pipe(flatMap(rooms => this.openRoom(roomToOpen)));\n  }\n\n  hasOpenedRooms(): boolean {\n    return this.openedRooms.length > 0;\n  }\n\n  createRoom(name: string, userIds: string[], withoutDuplicate: boolean): Observable<Room> {\n    return this.roomRepository.create(name, userIds, withoutDuplicate)\n                              .pipe(map(room => {\n                                this.addRoom(room);\n                                return room;\n                              }));\n  }\n\n  buildRoom(userIds: string[]): Room {\n    const users = userIds.map(id => new User(id, \"\"));\n    const noSenders = [];\n    const noMessage = [];\n    const noMessageUnread = 0;\n    const noId = undefined;\n    const initiator = this.toUser();\n    return new Room(noId,\n      undefined,\n      undefined,\n      true,\n      noMessageUnread,\n      users,\n      noSenders,\n      noMessage,\n      initiator,\n      this.roomRepository\n     );\n  }\n\n  sendMessage(room: Room, content: string, contentType: string): Observable<Message> {\n    return room.sendMessage({\n      content: content,\n      contentType: contentType,\n      deviceSessionId: this.deviceSessionId\n    });\n  }\n\n  isSentByMe(message: Message) {\n    return message && message.hasSenderId(this.id);\n  }\n\n  deleteMessage(message: Message): Observable<Message> {\n    if (message) {\n      const room = this.findRoomById(message.roomId);\n      if (room) {\n        return room.delete(message);\n      } else {\n        return of(undefined);\n      }\n    } else {\n      return of(undefined);\n    }\n  }\n\n  addUserTo(room: Room, userId: string): Observable<Room> {\n    return this.roomRepository.addUser(room, userId);\n  }\n\n  private addRooms(rooms: Room[]) {\n    rooms.forEach(room => {\n      this.addRoom(room);\n      if (room.open && !this.hasRoomOpened(room)) {\n        this.openedRooms.push(room);\n      }\n    });\n  }\n\n  private hasRoom(roomToFind: Room): boolean {\n    return this.findRoom(roomToFind) !== undefined;\n  }\n\n  private hasRoomOpened(roomToFind: Room): boolean {\n    return this.findRoomOpened(roomToFind) !== undefined;\n  }\n\n  private findRoom(room: Room): Room {\n    return this.findRoomById(room.id);\n  }\n\n  private findRoomOpened(roomToFind: Room): Room {\n    return this.openedRooms ? this.openedRooms.find(room => roomToFind.id === room.id) : undefined;\n  }\n\n  private addToOpenedRoom(room: Room) {\n    if (!this.hasRoomOpened(room)) {\n      this.openedRooms.push(room);\n    }\n  }\n\n  private removeFromOpenedRoom(closedRoom: Room) {\n    if (this.hasRoomOpened(closedRoom)) {\n      const roomIndex = this.openedRooms ? this.openedRooms.findIndex(room => room.id === closedRoom.id) : undefined;\n      this.openedRooms.splice(roomIndex, 1);\n    }\n  }\n\n  private markAllReceivedMessagesAsRead(room: Room): Observable<Room> {\n    return room.markAllMessagesAsRead()\n               .pipe(map(readMessageCount => {\n                  this.unreadMessageCount = Math.max(this.unreadMessageCount - readMessageCount, 0);\n                  return room;\n                }));\n  }\n\n  private toUser(): User {\n    return new User(this.id, \"\");\n  }\n}\n","import { HttpClient } from \"@angular/common/http\";\nimport { Inject, Injectable } from \"@angular/core\";\nimport { Observable } from \"rxjs\";\nimport { empty } from \"rxjs\";\nimport { catchError, map } from \"rxjs/operators\";\nimport { BabiliUrlConfiguration, URL_CONFIGURATION } from \"../configuration/url-configuration.types\";\nimport { RoomRepository } from \"./../room/room.repository\";\nimport { Me } from \"./me.types\";\n\n@Injectable()\nexport class MeRepository {\n\n  private userUrl: string;\n  private aliveUrl: string;\n\n  constructor(private http: HttpClient,\n              private roomRepository: RoomRepository,\n              @Inject(URL_CONFIGURATION) configuration: BabiliUrlConfiguration) {\n    this.userUrl = `${configuration.apiUrl}/user`;\n    this.aliveUrl = `${this.userUrl}/alive`;\n  }\n\n  findMe(): Observable<Me> {\n    return this.http.get(this.userUrl).pipe(map(me => Me.build(me, this.roomRepository)));\n  }\n\n  updateAliveness(me: Me): Observable<void> {\n    return this.http.put(this.aliveUrl, { data: { type: \"alive\" }})\n                    .pipe(catchError(() => empty()), map(() => null));\n  }\n}\n\n","import { Inject, Injectable } from \"@angular/core\";\nimport * as io from \"socket.io-client\";\nimport { BabiliUrlConfiguration, URL_CONFIGURATION } from \"./../configuration/url-configuration.types\";\n\n\n\n@Injectable()\nexport class BootstrapSocket {\n\n  private socket: SocketIOClient.Socket;\n\n  constructor(@Inject(URL_CONFIGURATION) private configuration: BabiliUrlConfiguration) {}\n\n  connect(token: string): SocketIOClient.Socket {\n    this.socket = io.connect(this.configuration.socketUrl, {\n      forceNew: true,\n      query: `token=${token}`\n    });\n    return this.socket;\n  }\n\n  socketExists(): boolean {\n    return this.socket !== undefined;\n  }\n\n  disconnect() {\n    if (this.socketExists()) {\n      this.socket.close();\n      this.socket = undefined;\n    }\n  }\n}\n","import { Inject, Injectable } from \"@angular/core\";\nimport { Observable, timer } from \"rxjs\";\nimport { map, publishReplay, refCount, share, takeWhile } from \"rxjs/operators\";\nimport { TokenConfiguration } from \"./../configuration/token-configuration.types\";\nimport { BabiliUrlConfiguration, URL_CONFIGURATION } from \"./../configuration/url-configuration.types\";\nimport { Message } from \"./../message/message.types\";\nimport { BootstrapSocket } from \"./../socket/bootstrap.socket\";\nimport { MeRepository } from \"./me.repository\";\nimport { Me } from \"./me.types\";\n\n@Injectable()\nexport class MeService {\n\n  private cachedMe: Observable<Me>;\n  private alive: boolean;\n\n  constructor(private meRepository: MeRepository,\n              private socketClient: BootstrapSocket,\n              @Inject(URL_CONFIGURATION) private configuration: BabiliUrlConfiguration,\n              private tokenConfiguration: TokenConfiguration) {\n    this.alive = false;\n  }\n\n  setup(token: string): void {\n    if (!this.tokenConfiguration.isApiTokenSet()) {\n      this.tokenConfiguration.apiToken = token;\n    }\n  }\n\n  me(): Observable<Me> {\n    if (!this.hasCachedMe()) {\n      this.cachedMe = this.meRepository\n                          .findMe()\n                          .pipe(\n                            map(me => this.scheduleAliveness(me)),\n                            publishReplay(1),\n                            refCount(),\n                            share()\n                          );\n    }\n    return this.cachedMe.pipe(map(me => this.connectSocket(me)));\n  }\n\n  clear() {\n    this.tokenConfiguration.clear();\n    this.cachedMe = undefined;\n    this.alive = false;\n  }\n\n  private scheduleAliveness(me: Me): Me {\n    this.alive = true;\n    timer(0, this.configuration.aliveIntervalInMs).pipe(\n      takeWhile(() => this.alive)\n    )\n    .subscribe(() => this.meRepository.updateAliveness(me));\n    return me;\n  }\n\n  private hasCachedMe(): boolean {\n    return this.cachedMe !== undefined;\n  }\n\n  private connectSocket(me: Me): Me {\n    if (!this.socketClient.socketExists()) {\n      const socket = this.socketClient.connect(this.tokenConfiguration.apiToken);\n      socket.on(\"new message\", data => this.receiveNewMessage(data));\n      socket.on(\"connected\", data => me.deviceSessionId = data.deviceSessionId);\n    }\n    return me;\n  }\n\n  private receiveNewMessage(json: any) {\n    const message = Message.build(json.data);\n    this.me().subscribe(me => me.handleNewMessage(message));\n  }\n}\n","import { Pipe, PipeTransform } from \"@angular/core\";\nimport * as momentLoaded from \"moment\";\nimport { Room } from \"../room/room.types\";\nconst moment = momentLoaded;\n\n@Pipe({\n  name: \"sortRooms\"\n})\nexport class SortRoomPipe  implements PipeTransform {\n  transform(rooms: Room[], field: string): any[] {\n    if (rooms !== undefined && rooms !== null) {\n      return rooms.sort((room: Room, otherRoom: Room) => {\n        const lastActivityAt      = room.lastActivityAt;\n        const otherLastActivityAt = otherRoom.lastActivityAt;\n        if (moment(lastActivityAt).isBefore(otherLastActivityAt)) {\n          return 1;\n        } else if (moment(otherLastActivityAt).isBefore(lastActivityAt)) {\n          return -1;\n        } else {\n          return 0;\n        }\n      });\n    } else {\n      return rooms;\n    }\n  }\n}\n","import { HTTP_INTERCEPTORS, HttpClientModule } from \"@angular/common/http\";\nimport { ModuleWithProviders, NgModule } from \"@angular/core\";\nimport { HttpAuthenticationInterceptor } from \"./authentication/http-authentication-interceptor\";\nimport { TokenConfiguration } from \"./configuration/token-configuration.types\";\nimport { BabiliUrlConfiguration, URL_CONFIGURATION } from \"./configuration/url-configuration.types\";\nimport { MeRepository } from \"./me/me.repository\";\nimport { MeService } from \"./me/me.service\";\nimport { MessageRepository } from \"./message/message.repository\";\nimport { SortRoomPipe } from \"./pipe/sort-room\";\nimport { RoomRepository } from \"./room/room.repository\";\nimport { BootstrapSocket } from \"./socket/bootstrap.socket\";\n\n@NgModule({\n  imports: [\n    HttpClientModule\n  ],\n  declarations: [\n    SortRoomPipe\n  ],\n  exports: [\n    SortRoomPipe\n  ]\n })\nexport class BabiliModule {\n  static forRoot(urlConfiguration: BabiliUrlConfiguration): ModuleWithProviders {\n    return {\n      ngModule: BabiliModule,\n      providers: [\n        {\n          provide: URL_CONFIGURATION,\n          useValue: urlConfiguration\n        },\n        SortRoomPipe,\n        TokenConfiguration,\n        BootstrapSocket,\n        {\n          provide: HTTP_INTERCEPTORS,\n          useClass: HttpAuthenticationInterceptor,\n          multi: true\n        },\n        MessageRepository,\n        RoomRepository,\n        MeRepository,\n        MeService\n      ]\n    };\n  }\n}\n"]}