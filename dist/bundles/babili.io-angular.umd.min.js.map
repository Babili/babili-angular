{"version":3,"sources":["ng://@babili.io/angular/pipe/sort-room.ts","ng://@babili.io/angular/configuration/token-configuration.types.ts","ng://@babili.io/angular/configuration/url-configuration.types.ts","ng://@babili.io/angular/authentication/not-authorized-error.ts","ng://@babili.io/angular/authentication/http-authentication-interceptor.ts","ng://@babili.io/angular/user/user.types.ts","ng://@babili.io/angular/message/message.types.ts","ng://@babili.io/angular/message/message.repository.ts","ng://@babili.io/angular/array.utils.ts","ng://@babili.io/angular/room/room.types.ts","ng://@babili.io/angular/room/room.repository.ts","ng://@babili.io/angular/me/me.types.ts","ng://@babili.io/angular/me/me.repository.ts","ng://@babili.io/angular/socket/bootstrap.socket.ts","ng://@babili.io/angular/me/me.service.ts","ng://@babili.io/angular/babili.module.ts"],"names":["moment","momentLoaded","SortRoomPipe","prototype","transform","rooms","field","undefined","sort","room","otherRoom","lastActivityAt","otherLastActivityAt","isBefore","Pipe","args","name","TokenConfiguration","isApiTokenSet","this","apiToken","clear","Injectable","URL_CONFIGURATION","InjectionToken","NotAuthorizedError","error","HttpAuthenticationInterceptor","urls","tokenConfiguration","intercept","request","next","shouldAddHeaderTo","handle","addHeaderTo","pipe","catchError","HttpErrorResponse","status","throwError","token","clone","headers","set","url","startsWith","apiUrl","Inject","User","id","build","json","attributes","map","Message","content","contentType","createdAt","sender","roomId","toDate","relationships","data","hasSenderId","userId","MessageRepository","http","configuration","roomUrl","create","post","messageUrl","type","response","findAll","get","params","delete","message","HttpClient","ArrayUtils","findIndex","items","predicate","currentIndex","length","apply","find","item","Room","open","unreadMessageCount","users","senders","messages","initiator","roomRepository","internalOpen","BehaviorSubject","internalLastActivityAt","internalName","internalUnreadMessageCount","internalImageUrl","messageRepository","utc","Object","defineProperty","value","count","imageUrl","openMembership","updateMembership","closeMembership","markAllMessagesAsRead","markAllReceivedMessagesAsRead","addMessage","push","notifyNewMessage","newMessageNotifier","hasUser","user","fetchMoreMessage","_this","firstSeenMessageId","findMessages","unshift","findMessageWithId","update","sendMessage","newMessage","createMessage","removeMessage","messageToDelete","index","splice","deleteMessage","deletedMessage","replaceUsersWith","Array","addUser","RoomRepository","query","findOpenedRooms","onlyOpened","findClosedRooms","onlyClosed","findRoomsAfter","firstSeenRoomId","findRoomsByIds","roomIds","roomIds[]","put","lastReadMessageId","meta","of","userIds","withoutDuplicate","noDuplicate","newUser","Me","openedRooms","roomCount","internalRoomCount","fetchOpenedRooms","addRooms","fetchClosedRooms","fetchMoreRooms","firstSeenRoom","fetchRoomsById","fetchRoomById","addRoom","findOrFetchRoomById","findRoomById","handleNewMessage","subscribe","newRoom","hasRoom","isAfter","roomIndex","openRoom","hasRoomOpened","flatMap","openedRoom","addToOpenedRoom","closeRoom","closedRoom","removeFromOpenedRoom","closeRooms","roomsToClose","forEach","openRoomAndCloseOthers","roomToOpen","roomsToBeClosed","filter","hasOpenedRooms","createRoom","buildRoom","noId","toUser","deviceSessionId","isSentByMe","addUserTo","roomToFind","findRoom","findRoomOpened","readMessageCount","Math","max","MeRepository","userUrl","aliveUrl","findMe","me","updateAliveness","empty","BootstrapSocket","connect","socket","io.connect","socketUrl","forceNew","socketExists","disconnect","close","MeService","meRepository","socketClient","alive","setup","hasCachedMe","cachedMe","scheduleAliveness","publishReplay","refCount","share","connectSocket","timer","aliveIntervalInMs","takeWhile","on","receiveNewMessage","BabiliModule","forRoot","urlConfiguration","ngModule","providers","provide","useValue","HTTP_INTERCEPTORS","useClass","multi","NgModule","imports","HttpClientModule","declarations"],"mappings":"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","sourcesContent":["import { Pipe, PipeTransform } from \"@angular/core\";\nimport * as momentLoaded from \"moment\";\nimport { Room } from \"../room/room.types\";\nconst moment = momentLoaded;\n\n@Pipe({\n  name: \"sortRooms\"\n})\nexport class SortRoomPipe  implements PipeTransform {\n  transform(rooms: Room[], field: string): any[] {\n    if (rooms !== undefined && rooms !== null) {\n      return rooms.sort((room: Room, otherRoom: Room) => {\n        const lastActivityAt      = room.lastActivityAt;\n        const otherLastActivityAt = otherRoom.lastActivityAt;\n        if (moment(lastActivityAt).isBefore(otherLastActivityAt)) {\n          return 1;\n        } else if (moment(otherLastActivityAt).isBefore(lastActivityAt)) {\n          return -1;\n        } else {\n          return 0;\n        }\n      });\n    } else {\n      return rooms;\n    }\n  }\n}\n","import { Injectable } from \"@angular/core\";\n\n@Injectable()\nexport class TokenConfiguration {\n  public apiToken: string;\n\n  constructor() {}\n\n  isApiTokenSet(): boolean {\n    return this.apiToken !== undefined && this.apiToken !== null && this.apiToken !== \"\";\n  }\n\n  clear() {\n    this.apiToken = undefined;\n  }\n\n}\n","import { InjectionToken } from \"@angular/core\";\n\nexport const URL_CONFIGURATION = new InjectionToken<UrlConfiguration>(\"BabiliUrlConfiguration\");\n\nexport interface UrlConfiguration {\n  apiUrl: string;\n  socketUrl: string;\n  aliveIntervalInMs?: number;\n}\n","export class NotAuthorizedError {\n  constructor(readonly error: any) {}\n}\n","import { HttpErrorResponse, HttpEvent, HttpHandler, HttpInterceptor, HttpRequest } from \"@angular/common/http\";\nimport { Inject, Injectable } from \"@angular/core\";\nimport { Observable, throwError } from \"rxjs\";\nimport { catchError } from \"rxjs/operators\";\nimport { TokenConfiguration } from \"./../configuration/token-configuration.types\";\nimport { URL_CONFIGURATION, UrlConfiguration } from \"./../configuration/url-configuration.types\";\nimport { NotAuthorizedError } from \"./not-authorized-error\";\n\n@Injectable()\nexport class HttpAuthenticationInterceptor implements HttpInterceptor {\n\n  constructor(@Inject(URL_CONFIGURATION) private urls: UrlConfiguration,\n              private tokenConfiguration: TokenConfiguration) {}\n\n  intercept(request: HttpRequest<any>, next: HttpHandler): Observable<HttpEvent<any>> {\n    if (this.shouldAddHeaderTo(request)) {\n      return next.handle(this.addHeaderTo(request, this.tokenConfiguration.apiToken))\n                 .pipe(catchError(error => {\n                   if (error instanceof HttpErrorResponse && error.status === 401) {\n                     return throwError(new NotAuthorizedError(error));\n                   } else {\n                     return throwError(error);\n                   }\n                 }));\n    } else {\n      return next.handle(request);\n    }\n  }\n\n  private addHeaderTo(request: HttpRequest<any>, token: string): HttpRequest<any> {\n    return request.clone({\n      headers: request.headers.set(\"Authorization\", `Bearer ${token}`)\n    });\n  }\n\n  private shouldAddHeaderTo(request: HttpRequest<any>): boolean {\n    return request.url.startsWith(this.urls.apiUrl);\n  }\n}\n","export class User {\n  static build(json: any): User {\n    if (json) {\n      return new User(json.id, json.attributes ? json.attributes.status : undefined);\n    } else {\n      return undefined;\n    }\n  }\n\n  static map(json: any): User[] {\n    if (json) {\n      return json.map(User.build);\n    } else {\n      return undefined;\n    }\n  }\n\n  constructor(readonly id: string,\n              readonly status: string) {}\n}\n","import * as momentLoaded from \"moment\";\nconst moment = momentLoaded;\n\nimport { User } from \"../user/user.types\";\n\nexport class Message {\n\n  static build(json: any): Message {\n    const attributes = json.attributes;\n    return new Message(json.id,\n                        attributes.content,\n                        attributes.contentType,\n                        moment(attributes.createdAt).toDate(),\n                        json.relationships.sender ? User.build(json.relationships.sender.data) : undefined,\n                        json.relationships.room.data.id);\n  }\n\n  static map(json: any): Message[] {\n    if (json) {\n      return json.map(Message.build);\n    } else {\n      return undefined;\n    }\n  }\n\n  constructor(readonly id: string,\n              readonly content: string,\n              readonly contentType: string,\n              readonly createdAt: Date,\n              readonly sender: User,\n              readonly roomId: string) {}\n\n  hasSenderId(userId: string) {\n    return this.sender && this.sender.id === userId;\n  }\n}\n","import { HttpClient } from \"@angular/common/http\";\nimport { Inject, Injectable } from \"@angular/core\";\nimport { Observable } from \"rxjs\";\nimport { map } from \"rxjs/operators\";\nimport { URL_CONFIGURATION, UrlConfiguration } from \"../configuration/url-configuration.types\";\nimport { Room } from \"../room/room.types\";\nimport { Message } from \"./message.types\";\n\nexport class NewMessage {\n  content: string;\n  contentType: string;\n  deviceSessionId: string;\n}\n\n@Injectable()\nexport class MessageRepository {\n\n  private roomUrl: string;\n\n  constructor(private http: HttpClient,\n              @Inject(URL_CONFIGURATION) configuration: UrlConfiguration) {\n    this.roomUrl = `${configuration.apiUrl}/user/rooms`;\n  }\n\n  create(room: Room, attributes: NewMessage): Observable<Message> {\n    return this.http.post(this.messageUrl(room.id), {\n      data: {\n        type: \"message\",\n        attributes: attributes\n      }\n    }).pipe(map((response: any) => Message.build(response.data)));\n  }\n\n  findAll(room: Room, attributes: {[param: string]: string | string[]}): Observable<Message[]> {\n    return this.http.get(this.messageUrl(room.id), { params: attributes })\n                    .pipe(map((response: any) => Message.map(response.data)));\n  }\n\n  delete(room: Room, message: Message): Observable<Message> {\n    return this.http.delete(`${this.messageUrl(room.id)}/${message.id}`)\n                    .pipe(map(response => message));\n  }\n\n  private messageUrl(roomId: string) {\n    return `${this.roomUrl}/${roomId}/messages`;\n  }\n\n}\n","export class ArrayUtils {\n  /**\n   * Returns the index of the first element in the array where predicate is true, and -1\n   * otherwise.\n   * @param items array that will be inspected to find an element index\n   * @param predicate find calls predicate once for each element of the array, in ascending\n   * order, until it finds one where predicate returns true. If such an element is found,\n   * findIndex immediately returns that element index. Otherwise, findIndex returns -1.\n   */\n  static findIndex<T>(items: T[], predicate: (value: T, index: number) => boolean): number {\n    for (let currentIndex = 0; currentIndex < items.length; ++currentIndex) {\n      if (predicate.apply(items[currentIndex], currentIndex)) {\n        return currentIndex;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Returns the value of the first element in the array where predicate is true, and undefined\n   * otherwise.\n   * @param items array that will be inspected to find an element\n   * @param predicate find calls predicate once for each element of the array, in ascending\n   * order, until it finds one where predicate returns true. If such an element is found, find\n   * immediately returns that element value. Otherwise, find returns undefined.\n   */\n  static find<T>(items: T[], predicate: (value: T, index: number) => boolean): T {\n    for (let currentIndex = 0; currentIndex < items.length; ++currentIndex) {\n      const item = items[currentIndex];\n      if (predicate.apply(item, currentIndex)) {\n        return item;\n      }\n    }\n    return undefined;\n  }\n}\n","import * as momentLoaded from \"moment\";\nconst moment = momentLoaded;\nimport { BehaviorSubject, Observable } from \"rxjs\";\nimport { map } from \"rxjs/operators\";\nimport { ArrayUtils } from \"../array.utils\";\nimport { Message } from \"../message/message.types\";\nimport { User } from \"../user/user.types\";\nimport { MessageRepository, NewMessage } from \"./../message/message.repository\";\nimport { RoomRepository } from \"./room.repository\";\n\nexport class Room {\n\n  static build(json: any, roomRepository: RoomRepository, messageRepository: MessageRepository): Room {\n    const attributes = json.attributes;\n    const users = json.relationships && json.relationships.users ? User.map(json.relationships.users.data) : [];\n    const senders = json.relationships && json.relationships.senders ? User.map(json.relationships.senders.data) : [];\n    const messages = json.relationships && json.relationships.messages ? Message.map(json.relationships.messages.data) : [];\n    const initiator = json.relationships && json.relationships.initiator ? User.build(json.relationships.initiator.data) : undefined;\n    return new Room(json.id,\n                    attributes.name,\n                    attributes.lastActivityAt ? moment(attributes.lastActivityAt).utc().toDate() : undefined,\n                    attributes.open,\n                    attributes.unreadMessageCount,\n                    users,\n                    senders,\n                    messages,\n                    initiator,\n                    roomRepository);\n  }\n\n  static map(json: any, roomRepository: RoomRepository, messageRepository: MessageRepository): Room[] {\n    if (json) {\n      return json.map(room => Room.build(room, roomRepository, messageRepository));\n    } else {\n      return undefined;\n    }\n  }\n\n  newMessageNotifier: (message: Message) => any;\n  private internalOpen: BehaviorSubject<boolean>;\n  private internalUnreadMessageCount: BehaviorSubject<number>;\n  private internalName: BehaviorSubject<string>;\n  private internalLastActivityAt: BehaviorSubject<Date>;\n  private internalImageUrl: BehaviorSubject<string>;\n\n  constructor(readonly id: string,\n              name: string,\n              lastActivityAt: Date,\n              open: boolean,\n              unreadMessageCount: number,\n              readonly users: User[],\n              readonly senders: User[],\n              readonly messages: Message[],\n              readonly initiator: User,\n              private roomRepository: RoomRepository) {\n    this.internalOpen = new BehaviorSubject(open);\n    this.internalLastActivityAt = new BehaviorSubject(lastActivityAt);\n    this.internalName = new BehaviorSubject(name);\n    this.internalUnreadMessageCount = new BehaviorSubject(unreadMessageCount);\n    this.internalImageUrl = new BehaviorSubject(undefined);\n  }\n\n  get unreadMessageCount(): number {\n    return this.internalUnreadMessageCount.value;\n  }\n\n  set unreadMessageCount(count: number) {\n    this.internalUnreadMessageCount.next(count);\n  }\n\n  get observableUnreadMessageCount(): BehaviorSubject<number> {\n    return this.internalUnreadMessageCount;\n  }\n\n  get name(): string {\n    return this.internalName.value;\n  }\n\n  set name(name: string) {\n    this.internalName.next(name);\n  }\n\n  get observableName(): BehaviorSubject<string> {\n    return this.internalName;\n  }\n\n  get open(): boolean {\n    return this.internalOpen.value;\n  }\n\n  set open(open: boolean) {\n    this.internalOpen.next(open);\n  }\n\n  get observableOpen(): BehaviorSubject<boolean> {\n    return this.internalOpen;\n  }\n\n  get lastActivityAt(): Date {\n    return this.internalLastActivityAt.value;\n  }\n\n  set lastActivityAt(lastActivityAt: Date) {\n    this.internalLastActivityAt.next(lastActivityAt);\n  }\n\n  get observableLastActivityAt(): BehaviorSubject<Date> {\n    return this.internalLastActivityAt;\n  }\n\n  get imageUrl(): string {\n    return this.internalImageUrl.value;\n  }\n\n  set imageUrl(imageUrl: string) {\n    this.internalImageUrl.next(imageUrl);\n  }\n\n  get observableImageUrl(): BehaviorSubject<string> {\n    return this.internalImageUrl;\n  }\n\n\n  openMembership(): Observable<Room> {\n    return this.roomRepository.updateMembership(this, true);\n  }\n\n  closeMembership(): Observable<Room> {\n    return this.roomRepository.updateMembership(this, false);\n  }\n\n  markAllMessagesAsRead(): Observable<number> {\n    return this.roomRepository.markAllReceivedMessagesAsRead(this);\n  }\n\n  addMessage(message: Message) {\n    this.messages.push(message);\n    this.lastActivityAt = message.createdAt;\n  }\n\n  notifyNewMessage(message: Message) {\n    if (this.newMessageNotifier) {\n      this.newMessageNotifier.apply(message);\n    }\n  }\n\n\n  hasUser(userId: string): boolean {\n    return ArrayUtils.find(this.users.map(user => user.id), id => id === userId) !== undefined;\n  }\n\n  fetchMoreMessage(): Observable<Message[]> {\n    const params = {\n      firstSeenMessageId: this.messages.length > 0 ? this.messages[0].id : undefined\n    };\n    return this.roomRepository\n               .findMessages(this, params)\n               .pipe(\n      map(messages => {\n        this.messages.unshift.apply(this.messages, messages);\n        return messages;\n      })\n    );\n  }\n\n  findMessageWithId(id: string): Message {\n    return ArrayUtils.find(this.messages, message => message.id === id);\n  }\n\n  update(): Observable<Room> {\n    return this.roomRepository.update(this);\n  }\n\n  sendMessage(newMessage: NewMessage): Observable<Message> {\n    return this.roomRepository\n               .createMessage(this, newMessage)\n               .pipe(\n                 map(message => {\n                   this.addMessage(message);\n                   return message;\n                 })\n               );\n  }\n\n  removeMessage(messageToDelete: Message): Message {\n    const index = ArrayUtils.findIndex(this.messages, message => message.id === messageToDelete.id);\n    if (index > -1) {\n      this.messages.splice(index, 1);\n    }\n    return messageToDelete;\n  }\n\n  delete(message: Message): Observable<Message> {\n    return this.roomRepository\n               .deleteMessage(this, message)\n               .pipe(map(deletedMessage => this.removeMessage(deletedMessage)));\n  }\n\n  replaceUsersWith(room: Room): Room {\n    this.users.splice(0, this.users.length);\n    Array.prototype.push.apply(this.users, room.users);\n    return this;\n  }\n\n  addUser(user: User) {\n    if (!this.hasUser(user.id)) {\n      this.users.push(user);\n    }\n  }\n}\n","import { HttpClient } from \"@angular/common/http\";\nimport { Inject, Injectable } from \"@angular/core\";\nimport { Observable, of } from \"rxjs\";\nimport { map } from \"rxjs/operators\";\nimport { URL_CONFIGURATION, UrlConfiguration } from \"../configuration/url-configuration.types\";\nimport { MessageRepository, NewMessage } from \"../message/message.repository\";\nimport { User } from \"../user/user.types\";\nimport { Message } from \"./../message/message.types\";\nimport { Room } from \"./room.types\";\n\n@Injectable()\nexport class RoomRepository {\n\n  private roomUrl: string;\n\n  constructor(private http: HttpClient,\n              private messageRepository: MessageRepository,\n              @Inject(URL_CONFIGURATION) configuration: UrlConfiguration) {\n    this.roomUrl = `${configuration.apiUrl}/user/rooms`;\n  }\n\n  find(id: string): Observable<Room> {\n    return this.http.get(`${this.roomUrl}/${id}`)\n                    .pipe(map((json: any) => Room.build(json.data, this, this.messageRepository)));\n  }\n\n  findAll(query: {[param: string]: string | string[] }): Observable<Room[]> {\n    return this.http.get(this.roomUrl, { params: query })\n                    .pipe(map((json: any) => Room.map(json.data, this, this.messageRepository)));\n  }\n\n  findOpenedRooms(): Observable<Room[]> {\n    return this.findAll({ onlyOpened: \"true\" });\n  }\n\n  findClosedRooms(): Observable<Room[]> {\n    return this.findAll({ onlyClosed: \"true\" });\n  }\n\n  findRoomsAfter(id: string): Observable<Room[]> {\n    return this.findAll({ firstSeenRoomId: id });\n  }\n\n  findRoomsByIds(roomIds: string[]) {\n    return this.findAll({ \"roomIds[]\": roomIds });\n  }\n\n  updateMembership(room: Room, open: boolean): Observable<Room> {\n    return this.http.put(`${this.roomUrl}/${room.id}/membership`, {\n      data: {\n        type: \"membership\",\n        attributes: {\n          open: open\n        }\n      }\n    }).pipe(map((data: any) => {\n      room.open = data.data.attributes.open;\n      return room;\n    }));\n  }\n\n  markAllReceivedMessagesAsRead(room: Room): Observable<number> {\n    if (room.unreadMessageCount > 0) {\n      const lastReadMessageId = room.messages.length > 0 ? room.messages[room.messages.length - 1].id : undefined;\n      return this.http.put(`${this.roomUrl}/${room.id}/membership/unread-messages`, { data: { lastReadMessageId: lastReadMessageId } })\n                      .pipe(map((data: any) => {\n                        room.unreadMessageCount = 0;\n                        return data.meta.count;\n                      }));\n    } else {\n      return of(0);\n    }\n  }\n\n  create(name: string, userIds: string[], withoutDuplicate: boolean): Observable<Room> {\n    return this.http.post(`${this.roomUrl}?noDuplicate=${withoutDuplicate}`, {\n      data: {\n        type: \"room\",\n        attributes: {\n          name: name\n        },\n        relationships: {\n          users: {\n            data: userIds.map(userId => ({ type: \"user\", id: userId }) )\n          }\n        }\n      }\n    }, {\n      params: {\n        noDuplicate: `${withoutDuplicate}`\n      }\n    }).pipe(map((response: any) => Room.build(response.data, this, this.messageRepository)));\n  }\n\n  update(room: Room): Observable<Room> {\n    return this.http.put(`${this.roomUrl}/${room.id}`, {\n      data: {\n        type: \"room\",\n        attributes: {\n          name: room.name\n        }\n      }\n    }).pipe(map((response: any) => {\n      room.name = response.data.attributes.name;\n      return room;\n    }));\n  }\n\n  addUser(room: Room, userId: string): Observable<Room> {\n    return this.http.post(`${this.roomUrl}/${room.id}/memberships`, {\n      data: {\n        type: \"membership\",\n        relationships: {\n          user: {\n            data: {\n              type: \"user\",\n              id: userId\n            }\n          }\n        }\n      }\n    }).pipe(map((response: any) => {\n      const newUser = User.build(response.data.relationships.user.data);\n      room.addUser(newUser);\n      return room;\n    }));\n  }\n\n  deleteMessage(room: Room, message: Message): Observable<Message> {\n    return this.messageRepository.delete(room, message);\n  }\n\n  findMessages(room: Room, attributes: {[param: string]: string | string[]}): Observable<Message[]> {\n    return this.messageRepository.findAll(room, attributes);\n  }\n\n  createMessage(room: Room, attributes: NewMessage): Observable<Message> {\n    return this.messageRepository.create(room, attributes);\n  }\n}\n","import * as momentLoaded from \"moment\";\nimport { BehaviorSubject, Observable, of } from \"rxjs\";\nimport { flatMap, map } from \"rxjs/operators\";\nimport { ArrayUtils } from \"../array.utils\";\nimport { Room } from \"../room/room.types\";\nimport { User } from \"../user/user.types\";\nimport { Message } from \"./../message/message.types\";\nimport { RoomRepository } from \"./../room/room.repository\";\nconst moment = momentLoaded;\n\nexport class Me {\n\n  static build(json: any, roomRepository: RoomRepository): Me {\n    const unreadMessageCount = json.data && json.data.meta ? json.data.meta.unreadMessageCount : 0;\n    const roomCount = json.data && json.data.meta ? json.data.meta.roomCount : 0;\n    return new Me(json.data.id, [], [], unreadMessageCount, roomCount, roomRepository);\n  }\n\n  public deviceSessionId: string;\n  private internalUnreadMessageCount: BehaviorSubject<number>;\n  private internalRoomCount: BehaviorSubject<number>;\n  private firstSeenRoom: Room;\n\n  constructor(readonly id: string,\n              readonly openedRooms: Room[],\n              readonly rooms: Room[],\n              unreadMessageCount: number,\n              roomCount: number,\n              private roomRepository: RoomRepository) {\n    this.internalUnreadMessageCount = new BehaviorSubject(unreadMessageCount || 0);\n    this.internalRoomCount = new BehaviorSubject(roomCount || 0);\n  }\n\n\n  get unreadMessageCount(): number {\n    return this.internalUnreadMessageCount.value;\n  }\n\n  set unreadMessageCount(count: number) {\n    this.internalUnreadMessageCount.next(count);\n  }\n\n  get observableUnreadMessageCount(): BehaviorSubject<number> {\n    return this.internalUnreadMessageCount;\n  }\n\n  get roomCount(): number {\n    return this.internalRoomCount.value;\n  }\n\n  get observableRoomCount(): BehaviorSubject<number> {\n    return this.internalRoomCount;\n  }\n\n  fetchOpenedRooms(): Observable<Room[]> {\n    return this.roomRepository.findOpenedRooms().pipe(map(rooms => {\n      this.addRooms(rooms);\n      return rooms;\n    }));\n  }\n\n  fetchClosedRooms(): Observable<Room[]> {\n    return this.roomRepository.findClosedRooms().pipe(map(rooms => {\n      this.addRooms(rooms);\n      return rooms;\n    }));\n  }\n\n  fetchMoreRooms(): Observable<Room[]> {\n    if (this.firstSeenRoom) {\n      return this.roomRepository.findRoomsAfter(this.firstSeenRoom.id).pipe(map(rooms => {\n        this.addRooms(rooms);\n        return rooms;\n      }));\n    } else {\n      return of([]);\n    }\n  }\n\n  fetchRoomsById(roomIds: string[]): Observable<Room[]> {\n    return this.roomRepository.findRoomsByIds(roomIds).pipe(map(rooms => {\n      this.addRooms(rooms);\n      return rooms;\n    }));\n  }\n\n  fetchRoomById(roomId: string): Observable<Room> {\n    return this.roomRepository.find(roomId).pipe(map(room => {\n      this.addRoom(room);\n      return room;\n    }));\n  }\n\n  findOrFetchRoomById(roomId: string): Observable<Room> {\n    const room = this.findRoomById(roomId);\n    if (roomId) {\n      return of(room);\n    } else {\n      return this.fetchRoomById(roomId);\n    }\n  }\n\n  handleNewMessage(newMessage: Message) {\n    this.findOrFetchRoomById(newMessage.roomId)\n        .subscribe(room => {\n          if (room) {\n            room.addMessage(newMessage);\n            room.notifyNewMessage(newMessage);\n            if (!newMessage.hasSenderId(this.id)) {\n              this.unreadMessageCount = this.unreadMessageCount + 1;\n              if (!room.open) {\n                room.unreadMessageCount = room.unreadMessageCount + 1;\n              }\n            }\n          }\n        });\n  }\n\n  addRoom(newRoom: Room) {\n    if (!this.hasRoom(newRoom)) {\n      if (!this.firstSeenRoom || moment(this.firstSeenRoom.lastActivityAt).isAfter(newRoom.lastActivityAt)) {\n        this.firstSeenRoom = newRoom;\n      }\n\n      const roomIndex = ArrayUtils.findIndex(this.rooms, room => room.id === newRoom.id);\n      if (roomIndex > -1) {\n        this.rooms[roomIndex] = newRoom;\n      } else {\n        this.rooms.push(newRoom);\n      }\n    }\n  }\n\n  findRoomById(roomId: string): Room {\n    return ArrayUtils.find(this.rooms, room => roomId === room.id);\n  }\n\n  openRoom(room: Room): Observable<Room> {\n    if (!this.hasRoomOpened(room)) {\n      return room.openMembership()\n                 .pipe(flatMap((openedRoom: Room) => {\n                   this.addToOpenedRoom(openedRoom);\n                   return this.markAllReceivedMessagesAsRead(openedRoom);\n                 }));\n    } else {\n      return of(room);\n    }\n  }\n\n  closeRoom(room: Room): Observable<Room> {\n    if (this.hasRoomOpened(room)) {\n      return room.closeMembership()\n                 .pipe(map(closedRoom => {\n                    this.removeFromOpenedRoom(closedRoom);\n                    return closedRoom;\n                  }));\n    } else {\n      return of(room);\n    }\n  }\n\n  closeRooms(roomsToClose: Room[]): Observable<Room[]> {\n    return of(roomsToClose).pipe(\n      map(rooms => {\n        rooms.forEach(room => this.closeRoom(room));\n        return rooms;\n      })\n    );\n  }\n\n  openRoomAndCloseOthers(roomToOpen: Room): Observable<Room> {\n    const roomsToBeClosed = this.openedRooms.filter(room => room.id !== roomToOpen.id);\n    return this.closeRooms(roomsToBeClosed).pipe(flatMap(rooms => this.openRoom(roomToOpen)));\n  }\n\n  hasOpenedRooms(): boolean {\n    return this.openedRooms.length > 0;\n  }\n\n  createRoom(name: string, userIds: string[], withoutDuplicate: boolean): Observable<Room> {\n    return this.roomRepository.create(name, userIds, withoutDuplicate)\n                              .pipe(map(room => {\n                                this.addRoom(room);\n                                return room;\n                              }));\n  }\n\n  buildRoom(userIds: string[]): Room {\n    const users = userIds.map(id => new User(id, \"\"));\n    const noSenders = [];\n    const noMessage = [];\n    const noMessageUnread = 0;\n    const noId = undefined;\n    const initiator = this.toUser();\n    return new Room(noId,\n      undefined,\n      undefined,\n      true,\n      noMessageUnread,\n      users,\n      noSenders,\n      noMessage,\n      initiator,\n      this.roomRepository\n     );\n  }\n\n  sendMessage(room: Room, content: string, contentType: string): Observable<Message> {\n    return room.sendMessage({\n      content: content,\n      contentType: contentType,\n      deviceSessionId: this.deviceSessionId\n    });\n  }\n\n  isSentByMe(message: Message) {\n    return message && message.hasSenderId(this.id);\n  }\n\n  deleteMessage(message: Message): Observable<Message> {\n    if (message) {\n      const room = this.findRoomById(message.roomId);\n      if (room) {\n        return room.delete(message);\n      } else {\n        return of(undefined);\n      }\n    } else {\n      return of(undefined);\n    }\n  }\n\n  addUserTo(room: Room, userId: string): Observable<Room> {\n    return this.roomRepository.addUser(room, userId);\n  }\n\n  private addRooms(rooms: Room[]) {\n    rooms.forEach(room => {\n      this.addRoom(room);\n      if (room.open && !this.hasRoomOpened(room)) {\n        this.openedRooms.push(room);\n      }\n    });\n  }\n\n  private hasRoom(roomToFind: Room): boolean {\n    return this.findRoom(roomToFind) !== undefined;\n  }\n\n  private hasRoomOpened(roomToFind: Room): boolean {\n    return this.findRoomOpened(roomToFind) !== undefined;\n  }\n\n  private findRoom(room: Room): Room {\n    return this.findRoomById(room.id);\n  }\n\n  private findRoomOpened(roomToFind: Room): Room {\n    return ArrayUtils.find(this.openedRooms, room => roomToFind.id === room.id);\n  }\n\n  private addToOpenedRoom(room: Room) {\n    if (!this.hasRoomOpened(room)) {\n      this.openedRooms.push(room);\n    }\n  }\n\n  private removeFromOpenedRoom(closedRoom: Room) {\n    if (this.hasRoomOpened(closedRoom)) {\n      const roomIndex = ArrayUtils.findIndex(this.openedRooms, room => room.id === closedRoom.id);\n      this.openedRooms.splice(roomIndex, 1);\n    }\n  }\n\n  private markAllReceivedMessagesAsRead(room: Room): Observable<Room> {\n    return room.markAllMessagesAsRead()\n               .pipe(map(readMessageCount => {\n                  this.unreadMessageCount = Math.max(this.unreadMessageCount - readMessageCount, 0);\n                  return room;\n                }));\n  }\n\n  private toUser(): User {\n    return new User(this.id, \"\");\n  }\n}\n","import { HttpClient } from \"@angular/common/http\";\nimport { Inject, Injectable } from \"@angular/core\";\nimport { empty, Observable } from \"rxjs\";\nimport { catchError, map } from \"rxjs/operators\";\nimport { URL_CONFIGURATION, UrlConfiguration } from \"../configuration/url-configuration.types\";\nimport { RoomRepository } from \"./../room/room.repository\";\nimport { Me } from \"./me.types\";\n\n@Injectable()\nexport class MeRepository {\n\n  private userUrl: string;\n  private aliveUrl: string;\n\n  constructor(private http: HttpClient,\n              private roomRepository: RoomRepository,\n              @Inject(URL_CONFIGURATION) configuration: UrlConfiguration) {\n    this.userUrl = `${configuration.apiUrl}/user`;\n    this.aliveUrl = `${this.userUrl}/alive`;\n  }\n\n  findMe(): Observable<Me> {\n    return this.http.get(this.userUrl).pipe(map(me => Me.build(me, this.roomRepository)));\n  }\n\n  updateAliveness(me: Me): Observable<void> {\n    return this.http.put(this.aliveUrl, { data: { type: \"alive\" }})\n                    .pipe(catchError(() => empty()), map(() => null));\n  }\n}\n\n","import { Inject, Injectable } from \"@angular/core\";\nimport { Observable } from \"rxjs\";\nimport * as io from \"socket.io-client\";\nimport { URL_CONFIGURATION, UrlConfiguration } from \"./../configuration/url-configuration.types\";\n\n\n\n@Injectable()\nexport class BootstrapSocket {\n\n  private socket: SocketIOClient.Socket;\n\n  constructor(@Inject(URL_CONFIGURATION) private configuration: UrlConfiguration) {}\n\n  connect(token: string): SocketIOClient.Socket {\n    this.socket = io.connect(this.configuration.socketUrl, {\n      forceNew: true,\n      query: `token=${token}`\n    });\n    return this.socket;\n  }\n\n  socketExists(): boolean {\n    return this.socket !== undefined;\n  }\n\n  disconnect() {\n    if (this.socketExists()) {\n      this.socket.close();\n      this.socket = undefined;\n    }\n  }\n}\n","import { HttpClient } from \"@angular/common/http\";\nimport { Inject, Injectable } from \"@angular/core\";\nimport { Observable, timer } from \"rxjs\";\nimport { map, publishReplay, refCount, share, takeWhile } from \"rxjs/operators\";\nimport { Room } from \"../room/room.types\";\nimport { TokenConfiguration } from \"./../configuration/token-configuration.types\";\nimport { URL_CONFIGURATION, UrlConfiguration } from \"./../configuration/url-configuration.types\";\nimport { Message } from \"./../message/message.types\";\nimport { BootstrapSocket } from \"./../socket/bootstrap.socket\";\nimport { MeRepository } from \"./me.repository\";\nimport { Me } from \"./me.types\";\n\n@Injectable()\nexport class MeService {\n\n  private cachedMe: Observable<Me>;\n  private alive: boolean;\n\n  constructor(private meRepository: MeRepository,\n              private socketClient: BootstrapSocket,\n              @Inject(URL_CONFIGURATION) private configuration: UrlConfiguration,\n              private tokenConfiguration: TokenConfiguration) {\n    this.alive = false;\n  }\n\n  setup(token: string): void {\n    if (!this.tokenConfiguration.isApiTokenSet()) {\n      this.tokenConfiguration.apiToken = token;\n    }\n  }\n\n  me(): Observable<Me> {\n    if (!this.hasCachedMe()) {\n      this.cachedMe = this.meRepository\n                          .findMe()\n                          .pipe(\n                            map(me => this.scheduleAliveness(me)),\n                            publishReplay(1),\n                            refCount(),\n                            share()\n                          );\n    }\n    return this.cachedMe.pipe(map(me => this.connectSocket(me)));\n  }\n\n  clear() {\n    this.tokenConfiguration.clear();\n    this.cachedMe = undefined;\n    this.alive = false;\n  }\n\n  private scheduleAliveness(me: Me): Me {\n    this.alive = true;\n    timer(0, this.configuration.aliveIntervalInMs).pipe(\n      takeWhile(() => this.alive)\n    )\n    .subscribe(() => this.meRepository.updateAliveness(me));\n    return me;\n  }\n\n  private hasCachedMe(): boolean {\n    return this.cachedMe !== undefined;\n  }\n\n  private connectSocket(me: Me): Me {\n    if (!this.socketClient.socketExists()) {\n      const socket = this.socketClient.connect(this.tokenConfiguration.apiToken);\n      socket.on(\"new message\", data => this.receiveNewMessage(data));\n      socket.on(\"connected\", data => me.deviceSessionId = data.deviceSessionId);\n    }\n    return me;\n  }\n\n  private receiveNewMessage(json: any) {\n    const message = Message.build(json.data);\n    this.me().subscribe(me => me.handleNewMessage(message));\n  }\n}\n","import { HTTP_INTERCEPTORS, HttpClientModule } from \"@angular/common/http\";\nimport { ModuleWithProviders, NgModule } from \"@angular/core\";\nimport { HttpAuthenticationInterceptor } from \"./authentication/http-authentication-interceptor\";\nimport { TokenConfiguration } from \"./configuration/token-configuration.types\";\nimport { URL_CONFIGURATION, UrlConfiguration } from \"./configuration/url-configuration.types\";\nimport { MeRepository } from \"./me/me.repository\";\nimport { MeService } from \"./me/me.service\";\nimport { MessageRepository } from \"./message/message.repository\";\nimport { SortRoomPipe } from \"./pipe/sort-room\";\nimport { RoomRepository } from \"./room/room.repository\";\nimport { BootstrapSocket } from \"./socket/bootstrap.socket\";\n\n@NgModule({\n  imports: [\n    HttpClientModule\n  ],\n  declarations: [\n    SortRoomPipe\n  ]\n })\nexport class BabiliModule {\n  static forRoot(urlConfiguration: UrlConfiguration): ModuleWithProviders {\n    return {\n      ngModule: BabiliModule,\n      providers: [\n        {\n          provide: URL_CONFIGURATION,\n          useValue: urlConfiguration\n        },\n        SortRoomPipe,\n        TokenConfiguration,\n        BootstrapSocket,\n        {\n          provide: HTTP_INTERCEPTORS,\n          useClass: HttpAuthenticationInterceptor,\n          multi: true\n        },\n        MessageRepository,\n        RoomRepository,\n        MeRepository,\n        MeService\n      ]\n    };\n  }\n}\n"]}