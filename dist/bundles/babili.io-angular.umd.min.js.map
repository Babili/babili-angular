{"version":3,"sources":["ng://@babili.io/angular/configuration/token-configuration.types.ts","ng://@babili.io/angular/configuration/url-configuration.types.ts","ng://@babili.io/angular/authentication/not-authorized-error.ts","ng://@babili.io/angular/authentication/http-authentication-interceptor.ts","ng://@babili.io/angular/user/user.types.ts","ng://@babili.io/angular/message/message.types.ts","ng://@babili.io/angular/message/message.repository.ts","ng://@babili.io/angular/array.utils.ts","ng://@babili.io/angular/room/room.types.ts","ng://@babili.io/angular/room/room.repository.ts","ng://@babili.io/angular/me/me.types.ts","ng://@babili.io/angular/me/me.repository.ts","ng://@babili.io/angular/socket/bootstrap.socket.ts","ng://@babili.io/angular/me/me.service.ts","ng://@babili.io/angular/pipe/sort-room.ts","ng://@babili.io/angular/babili.module.ts"],"names":["TokenConfiguration","prototype","isApiTokenSet","this","apiToken","undefined","clear","Injectable","URL_CONFIGURATION","InjectionToken","NotAuthorizedError","error","HttpAuthenticationInterceptor","urls","tokenConfiguration","intercept","request","next","shouldAddHeaderTo","handle","addHeaderTo","pipe","catchError","HttpErrorResponse","status","throwError","token","clone","headers","set","url","startsWith","apiUrl","Inject","args","User","id","build","json","attributes","map","moment","momentLoaded","Message","content","contentType","createdAt","sender","roomId","toDate","relationships","data","room","hasSenderId","userId","MessageRepository","http","configuration","roomUrl","create","post","messageUrl","type","response","findAll","get","params","delete","message","HttpClient","ArrayUtils","findIndex","items","predicate","currentIndex","length","apply","find","item","Room","name","lastActivityAt","open","unreadMessageCount","users","senders","messages","initiator","roomRepository","internalOpen","BehaviorSubject","internalLastActivityAt","internalName","internalUnreadMessageCount","internalImageUrl","messageRepository","utc","Object","defineProperty","value","count","imageUrl","openMembership","updateMembership","closeMembership","markAllMessagesAsRead","markAllReceivedMessagesAsRead","addMessage","push","notifyNewMessage","newMessageNotifier","hasUser","user","fetchMoreMessage","_this","firstSeenMessageId","findMessages","unshift","findMessageWithId","update","sendMessage","newMessage","createMessage","removeMessage","messageToDelete","index","splice","deleteMessage","deletedMessage","replaceUsersWith","Array","addUser","RoomRepository","query","findOpenedRooms","onlyOpened","findClosedRooms","onlyClosed","findRoomsAfter","firstSeenRoomId","findRoomsByIds","roomIds","roomIds[]","put","lastReadMessageId","meta","of","userIds","withoutDuplicate","noDuplicate","newUser","Me","openedRooms","rooms","roomCount","internalRoomCount","fetchOpenedRooms","addRooms","fetchClosedRooms","fetchMoreRooms","firstSeenRoom","fetchRoomsById","fetchRoomById","addRoom","findOrFetchRoomById","findRoomById","handleNewMessage","subscribe","newRoom","hasRoom","isAfter","roomIndex","openRoom","hasRoomOpened","flatMap","openedRoom","addToOpenedRoom","closeRoom","closedRoom","removeFromOpenedRoom","closeRooms","roomsToClose","forEach","openRoomAndCloseOthers","roomToOpen","roomsToBeClosed","filter","hasOpenedRooms","createRoom","buildRoom","noId","toUser","deviceSessionId","isSentByMe","addUserTo","roomToFind","findRoom","findRoomOpened","readMessageCount","Math","max","MeRepository","userUrl","aliveUrl","findMe","me","updateAliveness","empty","BootstrapSocket","connect","socket","io.connect","socketUrl","forceNew","socketExists","disconnect","close","MeService","meRepository","socketClient","alive","setup","hasCachedMe","cachedMe","scheduleAliveness","publishReplay","refCount","share","connectSocket","timer","aliveIntervalInMs","takeWhile","on","receiveNewMessage","SortRoomPipe","transform","field","sort","otherRoom","otherLastActivityAt","isBefore","Pipe","BabiliModule","forRoot","urlConfiguration","ngModule","providers","provide","useValue","HTTP_INTERCEPTORS","useClass","multi","NgModule","imports","HttpClientModule","declarations","exports"],"mappings":"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","sourcesContent":["import { Injectable } from \"@angular/core\";\n\n@Injectable()\nexport class TokenConfiguration {\n  public apiToken: string;\n\n  constructor() {}\n\n  isApiTokenSet(): boolean {\n    return this.apiToken !== undefined && this.apiToken !== null && this.apiToken !== \"\";\n  }\n\n  clear() {\n    this.apiToken = undefined;\n  }\n\n}\n","import { InjectionToken } from \"@angular/core\";\n\nexport const URL_CONFIGURATION = new InjectionToken<BabiliUrlConfiguration>(\"BabiliUrlConfiguration\");\n\nexport interface BabiliUrlConfiguration {\n  apiUrl: string;\n  socketUrl: string;\n  aliveIntervalInMs?: number;\n}\n","export class NotAuthorizedError {\n  constructor(readonly error: any) {}\n}\n","import { HttpErrorResponse, HttpEvent, HttpHandler, HttpInterceptor, HttpRequest } from \"@angular/common/http\";\nimport { Inject, Injectable } from \"@angular/core\";\nimport { Observable, throwError } from \"rxjs\";\nimport { catchError } from \"rxjs/operators\";\nimport { TokenConfiguration } from \"./../configuration/token-configuration.types\";\nimport { BabiliUrlConfiguration, URL_CONFIGURATION } from \"./../configuration/url-configuration.types\";\nimport { NotAuthorizedError } from \"./not-authorized-error\";\n\n@Injectable()\nexport class HttpAuthenticationInterceptor implements HttpInterceptor {\n\n  constructor(@Inject(URL_CONFIGURATION) private urls: BabiliUrlConfiguration,\n              private tokenConfiguration: TokenConfiguration) {}\n\n  intercept(request: HttpRequest<any>, next: HttpHandler): Observable<HttpEvent<any>> {\n    if (this.shouldAddHeaderTo(request)) {\n      return next.handle(this.addHeaderTo(request, this.tokenConfiguration.apiToken))\n                 .pipe(catchError(error => {\n                   if (error instanceof HttpErrorResponse && error.status === 401) {\n                     return throwError(new NotAuthorizedError(error));\n                   } else {\n                     return throwError(error);\n                   }\n                 }));\n    } else {\n      return next.handle(request);\n    }\n  }\n\n  private addHeaderTo(request: HttpRequest<any>, token: string): HttpRequest<any> {\n    return request.clone({\n      headers: request.headers.set(\"Authorization\", `Bearer ${token}`)\n    });\n  }\n\n  private shouldAddHeaderTo(request: HttpRequest<any>): boolean {\n    return request.url.startsWith(this.urls.apiUrl);\n  }\n}\n","export class User {\n  static build(json: any): User {\n    if (json) {\n      return new User(json.id, json.attributes ? json.attributes.status : undefined);\n    } else {\n      return undefined;\n    }\n  }\n\n  static map(json: any): User[] {\n    if (json) {\n      return json.map(User.build);\n    } else {\n      return undefined;\n    }\n  }\n\n  constructor(readonly id: string,\n              readonly status: string) {}\n}\n","import * as momentLoaded from \"moment\";\nconst moment = momentLoaded;\n\nimport { User } from \"../user/user.types\";\n\nexport class Message {\n\n  static build(json: any): Message {\n    const attributes = json.attributes;\n    return new Message(json.id,\n                        attributes.content,\n                        attributes.contentType,\n                        moment(attributes.createdAt).toDate(),\n                        json.relationships.sender ? User.build(json.relationships.sender.data) : undefined,\n                        json.relationships.room.data.id);\n  }\n\n  static map(json: any): Message[] {\n    if (json) {\n      return json.map(Message.build);\n    } else {\n      return undefined;\n    }\n  }\n\n  constructor(readonly id: string,\n              readonly content: string,\n              readonly contentType: string,\n              readonly createdAt: Date,\n              readonly sender: User,\n              readonly roomId: string) {}\n\n  hasSenderId(userId: string) {\n    return this.sender && this.sender.id === userId;\n  }\n}\n","import { HttpClient } from \"@angular/common/http\";\nimport { Inject, Injectable } from \"@angular/core\";\nimport { Observable } from \"rxjs\";\nimport { map } from \"rxjs/operators\";\nimport { BabiliUrlConfiguration, URL_CONFIGURATION } from \"../configuration/url-configuration.types\";\nimport { Room } from \"../room/room.types\";\nimport { Message } from \"./message.types\";\n\nexport class NewMessage {\n  content: string;\n  contentType: string;\n  deviceSessionId: string;\n}\n\n@Injectable()\nexport class MessageRepository {\n\n  private roomUrl: string;\n\n  constructor(private http: HttpClient,\n              @Inject(URL_CONFIGURATION) configuration: BabiliUrlConfiguration) {\n    this.roomUrl = `${configuration.apiUrl}/user/rooms`;\n  }\n\n  create(room: Room, attributes: NewMessage): Observable<Message> {\n    return this.http.post(this.messageUrl(room.id), {\n      data: {\n        type: \"message\",\n        attributes: attributes\n      }\n    }).pipe(map((response: any) => Message.build(response.data)));\n  }\n\n  findAll(room: Room, attributes: {[param: string]: string | string[]}): Observable<Message[]> {\n    return this.http.get(this.messageUrl(room.id), { params: attributes })\n                    .pipe(map((response: any) => Message.map(response.data)));\n  }\n\n  delete(room: Room, message: Message): Observable<Message> {\n    return this.http.delete(`${this.messageUrl(room.id)}/${message.id}`)\n                    .pipe(map(response => message));\n  }\n\n  private messageUrl(roomId: string) {\n    return `${this.roomUrl}/${roomId}/messages`;\n  }\n\n}\n","export class ArrayUtils {\n  /**\n   * Returns the index of the first element in the array where predicate is true, and -1\n   * otherwise.\n   * @param items array that will be inspected to find an element index\n   * @param predicate find calls predicate once for each element of the array, in ascending\n   * order, until it finds one where predicate returns true. If such an element is found,\n   * findIndex immediately returns that element index. Otherwise, findIndex returns -1.\n   */\n  static findIndex<T>(items: T[], predicate: (value: T, index: number) => boolean): number {\n    for (let currentIndex = 0; currentIndex < items.length; ++currentIndex) {\n      if (predicate.apply(items[currentIndex], currentIndex)) {\n        return currentIndex;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Returns the value of the first element in the array where predicate is true, and undefined\n   * otherwise.\n   * @param items array that will be inspected to find an element\n   * @param predicate find calls predicate once for each element of the array, in ascending\n   * order, until it finds one where predicate returns true. If such an element is found, find\n   * immediately returns that element value. Otherwise, find returns undefined.\n   */\n  static find<T>(items: T[], predicate: (value: T, index: number) => boolean): T {\n    for (let currentIndex = 0; currentIndex < items.length; ++currentIndex) {\n      const item = items[currentIndex];\n      if (predicate.apply(item, currentIndex)) {\n        return item;\n      }\n    }\n    return undefined;\n  }\n}\n","import * as momentLoaded from \"moment\";\nconst moment = momentLoaded;\nimport { BehaviorSubject, Observable } from \"rxjs\";\nimport { map } from \"rxjs/operators\";\nimport { ArrayUtils } from \"../array.utils\";\nimport { Message } from \"../message/message.types\";\nimport { User } from \"../user/user.types\";\nimport { MessageRepository, NewMessage } from \"./../message/message.repository\";\nimport { RoomRepository } from \"./room.repository\";\n\nexport class Room {\n\n  static build(json: any, roomRepository: RoomRepository, messageRepository: MessageRepository): Room {\n    const attributes = json.attributes;\n    const users = json.relationships && json.relationships.users ? User.map(json.relationships.users.data) : [];\n    const senders = json.relationships && json.relationships.senders ? User.map(json.relationships.senders.data) : [];\n    const messages = json.relationships && json.relationships.messages ? Message.map(json.relationships.messages.data) : [];\n    const initiator = json.relationships && json.relationships.initiator ? User.build(json.relationships.initiator.data) : undefined;\n    return new Room(json.id,\n                    attributes.name,\n                    attributes.lastActivityAt ? moment(attributes.lastActivityAt).utc().toDate() : undefined,\n                    attributes.open,\n                    attributes.unreadMessageCount,\n                    users,\n                    senders,\n                    messages,\n                    initiator,\n                    roomRepository);\n  }\n\n  static map(json: any, roomRepository: RoomRepository, messageRepository: MessageRepository): Room[] {\n    if (json) {\n      return json.map(room => Room.build(room, roomRepository, messageRepository));\n    } else {\n      return undefined;\n    }\n  }\n\n  newMessageNotifier: (message: Message) => any;\n  private internalOpen: BehaviorSubject<boolean>;\n  private internalUnreadMessageCount: BehaviorSubject<number>;\n  private internalName: BehaviorSubject<string>;\n  private internalLastActivityAt: BehaviorSubject<Date>;\n  private internalImageUrl: BehaviorSubject<string>;\n\n  constructor(readonly id: string,\n              name: string,\n              lastActivityAt: Date,\n              open: boolean,\n              unreadMessageCount: number,\n              readonly users: User[],\n              readonly senders: User[],\n              readonly messages: Message[],\n              readonly initiator: User,\n              private roomRepository: RoomRepository) {\n    this.internalOpen = new BehaviorSubject(open);\n    this.internalLastActivityAt = new BehaviorSubject(lastActivityAt);\n    this.internalName = new BehaviorSubject(name);\n    this.internalUnreadMessageCount = new BehaviorSubject(unreadMessageCount);\n    this.internalImageUrl = new BehaviorSubject(undefined);\n  }\n\n  get unreadMessageCount(): number {\n    return this.internalUnreadMessageCount.value;\n  }\n\n  set unreadMessageCount(count: number) {\n    this.internalUnreadMessageCount.next(count);\n  }\n\n  get observableUnreadMessageCount(): BehaviorSubject<number> {\n    return this.internalUnreadMessageCount;\n  }\n\n  get name(): string {\n    return this.internalName.value;\n  }\n\n  set name(name: string) {\n    this.internalName.next(name);\n  }\n\n  get observableName(): BehaviorSubject<string> {\n    return this.internalName;\n  }\n\n  get open(): boolean {\n    return this.internalOpen.value;\n  }\n\n  set open(open: boolean) {\n    this.internalOpen.next(open);\n  }\n\n  get observableOpen(): BehaviorSubject<boolean> {\n    return this.internalOpen;\n  }\n\n  get lastActivityAt(): Date {\n    return this.internalLastActivityAt.value;\n  }\n\n  set lastActivityAt(lastActivityAt: Date) {\n    this.internalLastActivityAt.next(lastActivityAt);\n  }\n\n  get observableLastActivityAt(): BehaviorSubject<Date> {\n    return this.internalLastActivityAt;\n  }\n\n  get imageUrl(): string {\n    return this.internalImageUrl.value;\n  }\n\n  set imageUrl(imageUrl: string) {\n    this.internalImageUrl.next(imageUrl);\n  }\n\n  get observableImageUrl(): BehaviorSubject<string> {\n    return this.internalImageUrl;\n  }\n\n\n  openMembership(): Observable<Room> {\n    return this.roomRepository.updateMembership(this, true);\n  }\n\n  closeMembership(): Observable<Room> {\n    return this.roomRepository.updateMembership(this, false);\n  }\n\n  markAllMessagesAsRead(): Observable<number> {\n    return this.roomRepository.markAllReceivedMessagesAsRead(this);\n  }\n\n  addMessage(message: Message) {\n    this.messages.push(message);\n    this.lastActivityAt = message.createdAt;\n  }\n\n  notifyNewMessage(message: Message) {\n    if (this.newMessageNotifier) {\n      this.newMessageNotifier.apply(message);\n    }\n  }\n\n\n  hasUser(userId: string): boolean {\n    return ArrayUtils.find(this.users.map(user => user.id), id => id === userId) !== undefined;\n  }\n\n  fetchMoreMessage(): Observable<Message[]> {\n    const params = {\n      firstSeenMessageId: this.messages.length > 0 ? this.messages[0].id : undefined\n    };\n    return this.roomRepository\n               .findMessages(this, params)\n               .pipe(\n      map(messages => {\n        this.messages.unshift.apply(this.messages, messages);\n        return messages;\n      })\n    );\n  }\n\n  findMessageWithId(id: string): Message {\n    return ArrayUtils.find(this.messages, message => message.id === id);\n  }\n\n  update(): Observable<Room> {\n    return this.roomRepository.update(this);\n  }\n\n  sendMessage(newMessage: NewMessage): Observable<Message> {\n    return this.roomRepository\n               .createMessage(this, newMessage)\n               .pipe(\n                 map(message => {\n                   this.addMessage(message);\n                   return message;\n                 })\n               );\n  }\n\n  removeMessage(messageToDelete: Message): Message {\n    const index = ArrayUtils.findIndex(this.messages, message => message.id === messageToDelete.id);\n    if (index > -1) {\n      this.messages.splice(index, 1);\n    }\n    return messageToDelete;\n  }\n\n  delete(message: Message): Observable<Message> {\n    return this.roomRepository\n               .deleteMessage(this, message)\n               .pipe(map(deletedMessage => this.removeMessage(deletedMessage)));\n  }\n\n  replaceUsersWith(room: Room): Room {\n    this.users.splice(0, this.users.length);\n    Array.prototype.push.apply(this.users, room.users);\n    return this;\n  }\n\n  addUser(user: User) {\n    if (!this.hasUser(user.id)) {\n      this.users.push(user);\n    }\n  }\n}\n","import { HttpClient } from \"@angular/common/http\";\nimport { Inject, Injectable } from \"@angular/core\";\nimport { Observable, of } from \"rxjs\";\nimport { map } from \"rxjs/operators\";\nimport { BabiliUrlConfiguration, URL_CONFIGURATION } from \"../configuration/url-configuration.types\";\nimport { MessageRepository, NewMessage } from \"../message/message.repository\";\nimport { User } from \"../user/user.types\";\nimport { Message } from \"./../message/message.types\";\nimport { Room } from \"./room.types\";\n\n@Injectable()\nexport class RoomRepository {\n\n  private roomUrl: string;\n\n  constructor(private http: HttpClient,\n              private messageRepository: MessageRepository,\n              @Inject(URL_CONFIGURATION) configuration: BabiliUrlConfiguration) {\n    this.roomUrl = `${configuration.apiUrl}/user/rooms`;\n  }\n\n  find(id: string): Observable<Room> {\n    return this.http.get(`${this.roomUrl}/${id}`)\n                    .pipe(map((json: any) => Room.build(json.data, this, this.messageRepository)));\n  }\n\n  findAll(query: {[param: string]: string | string[] }): Observable<Room[]> {\n    return this.http.get(this.roomUrl, { params: query })\n                    .pipe(map((json: any) => Room.map(json.data, this, this.messageRepository)));\n  }\n\n  findOpenedRooms(): Observable<Room[]> {\n    return this.findAll({ onlyOpened: \"true\" });\n  }\n\n  findClosedRooms(): Observable<Room[]> {\n    return this.findAll({ onlyClosed: \"true\" });\n  }\n\n  findRoomsAfter(id: string): Observable<Room[]> {\n    return this.findAll({ firstSeenRoomId: id });\n  }\n\n  findRoomsByIds(roomIds: string[]) {\n    return this.findAll({ \"roomIds[]\": roomIds });\n  }\n\n  updateMembership(room: Room, open: boolean): Observable<Room> {\n    return this.http.put(`${this.roomUrl}/${room.id}/membership`, {\n      data: {\n        type: \"membership\",\n        attributes: {\n          open: open\n        }\n      }\n    }).pipe(map((data: any) => {\n      room.open = data.data.attributes.open;\n      return room;\n    }));\n  }\n\n  markAllReceivedMessagesAsRead(room: Room): Observable<number> {\n    if (room.unreadMessageCount > 0) {\n      const lastReadMessageId = room.messages.length > 0 ? room.messages[room.messages.length - 1].id : undefined;\n      return this.http.put(`${this.roomUrl}/${room.id}/membership/unread-messages`, { data: { lastReadMessageId: lastReadMessageId } })\n                      .pipe(map((data: any) => {\n                        room.unreadMessageCount = 0;\n                        return data.meta.count;\n                      }));\n    } else {\n      return of(0);\n    }\n  }\n\n  create(name: string, userIds: string[], withoutDuplicate: boolean): Observable<Room> {\n    return this.http.post(`${this.roomUrl}?noDuplicate=${withoutDuplicate}`, {\n      data: {\n        type: \"room\",\n        attributes: {\n          name: name\n        },\n        relationships: {\n          users: {\n            data: userIds.map(userId => ({ type: \"user\", id: userId }) )\n          }\n        }\n      }\n    }, {\n      params: {\n        noDuplicate: `${withoutDuplicate}`\n      }\n    }).pipe(map((response: any) => Room.build(response.data, this, this.messageRepository)));\n  }\n\n  update(room: Room): Observable<Room> {\n    return this.http.put(`${this.roomUrl}/${room.id}`, {\n      data: {\n        type: \"room\",\n        attributes: {\n          name: room.name\n        }\n      }\n    }).pipe(map((response: any) => {\n      room.name = response.data.attributes.name;\n      return room;\n    }));\n  }\n\n  addUser(room: Room, userId: string): Observable<Room> {\n    return this.http.post(`${this.roomUrl}/${room.id}/memberships`, {\n      data: {\n        type: \"membership\",\n        relationships: {\n          user: {\n            data: {\n              type: \"user\",\n              id: userId\n            }\n          }\n        }\n      }\n    }).pipe(map((response: any) => {\n      const newUser = User.build(response.data.relationships.user.data);\n      room.addUser(newUser);\n      return room;\n    }));\n  }\n\n  deleteMessage(room: Room, message: Message): Observable<Message> {\n    return this.messageRepository.delete(room, message);\n  }\n\n  findMessages(room: Room, attributes: {[param: string]: string | string[]}): Observable<Message[]> {\n    return this.messageRepository.findAll(room, attributes);\n  }\n\n  createMessage(room: Room, attributes: NewMessage): Observable<Message> {\n    return this.messageRepository.create(room, attributes);\n  }\n}\n","import * as momentLoaded from \"moment\";\nimport { BehaviorSubject, Observable, of } from \"rxjs\";\nimport { flatMap, map } from \"rxjs/operators\";\nimport { ArrayUtils } from \"../array.utils\";\nimport { Room } from \"../room/room.types\";\nimport { User } from \"../user/user.types\";\nimport { Message } from \"./../message/message.types\";\nimport { RoomRepository } from \"./../room/room.repository\";\nconst moment = momentLoaded;\n\nexport class Me {\n\n  static build(json: any, roomRepository: RoomRepository): Me {\n    const unreadMessageCount = json.data && json.data.meta ? json.data.meta.unreadMessageCount : 0;\n    const roomCount = json.data && json.data.meta ? json.data.meta.roomCount : 0;\n    return new Me(json.data.id, [], [], unreadMessageCount, roomCount, roomRepository);\n  }\n\n  public deviceSessionId: string;\n  private internalUnreadMessageCount: BehaviorSubject<number>;\n  private internalRoomCount: BehaviorSubject<number>;\n  private firstSeenRoom: Room;\n\n  constructor(readonly id: string,\n              readonly openedRooms: Room[],\n              readonly rooms: Room[],\n              unreadMessageCount: number,\n              roomCount: number,\n              private roomRepository: RoomRepository) {\n    this.internalUnreadMessageCount = new BehaviorSubject(unreadMessageCount || 0);\n    this.internalRoomCount = new BehaviorSubject(roomCount || 0);\n  }\n\n\n  get unreadMessageCount(): number {\n    return this.internalUnreadMessageCount.value;\n  }\n\n  set unreadMessageCount(count: number) {\n    this.internalUnreadMessageCount.next(count);\n  }\n\n  get observableUnreadMessageCount(): BehaviorSubject<number> {\n    return this.internalUnreadMessageCount;\n  }\n\n  get roomCount(): number {\n    return this.internalRoomCount.value;\n  }\n\n  get observableRoomCount(): BehaviorSubject<number> {\n    return this.internalRoomCount;\n  }\n\n  fetchOpenedRooms(): Observable<Room[]> {\n    return this.roomRepository.findOpenedRooms().pipe(map(rooms => {\n      this.addRooms(rooms);\n      return rooms;\n    }));\n  }\n\n  fetchClosedRooms(): Observable<Room[]> {\n    return this.roomRepository.findClosedRooms().pipe(map(rooms => {\n      this.addRooms(rooms);\n      return rooms;\n    }));\n  }\n\n  fetchMoreRooms(): Observable<Room[]> {\n    if (this.firstSeenRoom) {\n      return this.roomRepository.findRoomsAfter(this.firstSeenRoom.id).pipe(map(rooms => {\n        this.addRooms(rooms);\n        return rooms;\n      }));\n    } else {\n      return of([]);\n    }\n  }\n\n  fetchRoomsById(roomIds: string[]): Observable<Room[]> {\n    return this.roomRepository.findRoomsByIds(roomIds).pipe(map(rooms => {\n      this.addRooms(rooms);\n      return rooms;\n    }));\n  }\n\n  fetchRoomById(roomId: string): Observable<Room> {\n    return this.roomRepository.find(roomId).pipe(map(room => {\n      this.addRoom(room);\n      return room;\n    }));\n  }\n\n  findOrFetchRoomById(roomId: string): Observable<Room> {\n    const room = this.findRoomById(roomId);\n    if (roomId) {\n      return of(room);\n    } else {\n      return this.fetchRoomById(roomId);\n    }\n  }\n\n  handleNewMessage(newMessage: Message) {\n    this.findOrFetchRoomById(newMessage.roomId)\n        .subscribe(room => {\n          if (room) {\n            room.addMessage(newMessage);\n            room.notifyNewMessage(newMessage);\n            if (!newMessage.hasSenderId(this.id)) {\n              this.unreadMessageCount = this.unreadMessageCount + 1;\n              if (!room.open) {\n                room.unreadMessageCount = room.unreadMessageCount + 1;\n              }\n            }\n          }\n        });\n  }\n\n  addRoom(newRoom: Room) {\n    if (!this.hasRoom(newRoom)) {\n      if (!this.firstSeenRoom || moment(this.firstSeenRoom.lastActivityAt).isAfter(newRoom.lastActivityAt)) {\n        this.firstSeenRoom = newRoom;\n      }\n\n      const roomIndex = ArrayUtils.findIndex(this.rooms, room => room.id === newRoom.id);\n      if (roomIndex > -1) {\n        this.rooms[roomIndex] = newRoom;\n      } else {\n        this.rooms.push(newRoom);\n      }\n    }\n  }\n\n  findRoomById(roomId: string): Room {\n    return ArrayUtils.find(this.rooms, room => roomId === room.id);\n  }\n\n  openRoom(room: Room): Observable<Room> {\n    if (!this.hasRoomOpened(room)) {\n      return room.openMembership()\n                 .pipe(flatMap((openedRoom: Room) => {\n                   this.addToOpenedRoom(openedRoom);\n                   return this.markAllReceivedMessagesAsRead(openedRoom);\n                 }));\n    } else {\n      return of(room);\n    }\n  }\n\n  closeRoom(room: Room): Observable<Room> {\n    if (this.hasRoomOpened(room)) {\n      return room.closeMembership()\n                 .pipe(map(closedRoom => {\n                    this.removeFromOpenedRoom(closedRoom);\n                    return closedRoom;\n                  }));\n    } else {\n      return of(room);\n    }\n  }\n\n  closeRooms(roomsToClose: Room[]): Observable<Room[]> {\n    return of(roomsToClose).pipe(\n      map(rooms => {\n        rooms.forEach(room => this.closeRoom(room));\n        return rooms;\n      })\n    );\n  }\n\n  openRoomAndCloseOthers(roomToOpen: Room): Observable<Room> {\n    const roomsToBeClosed = this.openedRooms.filter(room => room.id !== roomToOpen.id);\n    return this.closeRooms(roomsToBeClosed).pipe(flatMap(rooms => this.openRoom(roomToOpen)));\n  }\n\n  hasOpenedRooms(): boolean {\n    return this.openedRooms.length > 0;\n  }\n\n  createRoom(name: string, userIds: string[], withoutDuplicate: boolean): Observable<Room> {\n    return this.roomRepository.create(name, userIds, withoutDuplicate)\n                              .pipe(map(room => {\n                                this.addRoom(room);\n                                return room;\n                              }));\n  }\n\n  buildRoom(userIds: string[]): Room {\n    const users = userIds.map(id => new User(id, \"\"));\n    const noSenders = [];\n    const noMessage = [];\n    const noMessageUnread = 0;\n    const noId = undefined;\n    const initiator = this.toUser();\n    return new Room(noId,\n      undefined,\n      undefined,\n      true,\n      noMessageUnread,\n      users,\n      noSenders,\n      noMessage,\n      initiator,\n      this.roomRepository\n     );\n  }\n\n  sendMessage(room: Room, content: string, contentType: string): Observable<Message> {\n    return room.sendMessage({\n      content: content,\n      contentType: contentType,\n      deviceSessionId: this.deviceSessionId\n    });\n  }\n\n  isSentByMe(message: Message) {\n    return message && message.hasSenderId(this.id);\n  }\n\n  deleteMessage(message: Message): Observable<Message> {\n    if (message) {\n      const room = this.findRoomById(message.roomId);\n      if (room) {\n        return room.delete(message);\n      } else {\n        return of(undefined);\n      }\n    } else {\n      return of(undefined);\n    }\n  }\n\n  addUserTo(room: Room, userId: string): Observable<Room> {\n    return this.roomRepository.addUser(room, userId);\n  }\n\n  private addRooms(rooms: Room[]) {\n    rooms.forEach(room => {\n      this.addRoom(room);\n      if (room.open && !this.hasRoomOpened(room)) {\n        this.openedRooms.push(room);\n      }\n    });\n  }\n\n  private hasRoom(roomToFind: Room): boolean {\n    return this.findRoom(roomToFind) !== undefined;\n  }\n\n  private hasRoomOpened(roomToFind: Room): boolean {\n    return this.findRoomOpened(roomToFind) !== undefined;\n  }\n\n  private findRoom(room: Room): Room {\n    return this.findRoomById(room.id);\n  }\n\n  private findRoomOpened(roomToFind: Room): Room {\n    return ArrayUtils.find(this.openedRooms, room => roomToFind.id === room.id);\n  }\n\n  private addToOpenedRoom(room: Room) {\n    if (!this.hasRoomOpened(room)) {\n      this.openedRooms.push(room);\n    }\n  }\n\n  private removeFromOpenedRoom(closedRoom: Room) {\n    if (this.hasRoomOpened(closedRoom)) {\n      const roomIndex = ArrayUtils.findIndex(this.openedRooms, room => room.id === closedRoom.id);\n      this.openedRooms.splice(roomIndex, 1);\n    }\n  }\n\n  private markAllReceivedMessagesAsRead(room: Room): Observable<Room> {\n    return room.markAllMessagesAsRead()\n               .pipe(map(readMessageCount => {\n                  this.unreadMessageCount = Math.max(this.unreadMessageCount - readMessageCount, 0);\n                  return room;\n                }));\n  }\n\n  private toUser(): User {\n    return new User(this.id, \"\");\n  }\n}\n","import { HttpClient } from \"@angular/common/http\";\nimport { Inject, Injectable } from \"@angular/core\";\nimport { Observable } from \"rxjs\";\nimport { empty } from \"rxjs\";\nimport { catchError, map } from \"rxjs/operators\";\nimport { BabiliUrlConfiguration, URL_CONFIGURATION } from \"../configuration/url-configuration.types\";\nimport { RoomRepository } from \"./../room/room.repository\";\nimport { Me } from \"./me.types\";\n\n@Injectable()\nexport class MeRepository {\n\n  private userUrl: string;\n  private aliveUrl: string;\n\n  constructor(private http: HttpClient,\n              private roomRepository: RoomRepository,\n              @Inject(URL_CONFIGURATION) configuration: BabiliUrlConfiguration) {\n    this.userUrl = `${configuration.apiUrl}/user`;\n    this.aliveUrl = `${this.userUrl}/alive`;\n  }\n\n  findMe(): Observable<Me> {\n    return this.http.get(this.userUrl).pipe(map(me => Me.build(me, this.roomRepository)));\n  }\n\n  updateAliveness(me: Me): Observable<void> {\n    return this.http.put(this.aliveUrl, { data: { type: \"alive\" }})\n                    .pipe(catchError(() => empty()), map(() => null));\n  }\n}\n\n","import { Inject, Injectable } from \"@angular/core\";\nimport * as io from \"socket.io-client\";\nimport { BabiliUrlConfiguration, URL_CONFIGURATION } from \"./../configuration/url-configuration.types\";\n\n\n\n@Injectable()\nexport class BootstrapSocket {\n\n  private socket: SocketIOClient.Socket;\n\n  constructor(@Inject(URL_CONFIGURATION) private configuration: BabiliUrlConfiguration) {}\n\n  connect(token: string): SocketIOClient.Socket {\n    this.socket = io.connect(this.configuration.socketUrl, {\n      forceNew: true,\n      query: `token=${token}`\n    });\n    return this.socket;\n  }\n\n  socketExists(): boolean {\n    return this.socket !== undefined;\n  }\n\n  disconnect() {\n    if (this.socketExists()) {\n      this.socket.close();\n      this.socket = undefined;\n    }\n  }\n}\n","import { Inject, Injectable } from \"@angular/core\";\nimport { Observable, timer } from \"rxjs\";\nimport { map, publishReplay, refCount, share, takeWhile } from \"rxjs/operators\";\nimport { TokenConfiguration } from \"./../configuration/token-configuration.types\";\nimport { BabiliUrlConfiguration, URL_CONFIGURATION } from \"./../configuration/url-configuration.types\";\nimport { Message } from \"./../message/message.types\";\nimport { BootstrapSocket } from \"./../socket/bootstrap.socket\";\nimport { MeRepository } from \"./me.repository\";\nimport { Me } from \"./me.types\";\n\n@Injectable()\nexport class MeService {\n\n  private cachedMe: Observable<Me>;\n  private alive: boolean;\n\n  constructor(private meRepository: MeRepository,\n              private socketClient: BootstrapSocket,\n              @Inject(URL_CONFIGURATION) private configuration: BabiliUrlConfiguration,\n              private tokenConfiguration: TokenConfiguration) {\n    this.alive = false;\n  }\n\n  setup(token: string): void {\n    if (!this.tokenConfiguration.isApiTokenSet()) {\n      this.tokenConfiguration.apiToken = token;\n    }\n  }\n\n  me(): Observable<Me> {\n    if (!this.hasCachedMe()) {\n      this.cachedMe = this.meRepository\n                          .findMe()\n                          .pipe(\n                            map(me => this.scheduleAliveness(me)),\n                            publishReplay(1),\n                            refCount(),\n                            share()\n                          );\n    }\n    return this.cachedMe.pipe(map(me => this.connectSocket(me)));\n  }\n\n  clear() {\n    this.tokenConfiguration.clear();\n    this.cachedMe = undefined;\n    this.alive = false;\n  }\n\n  private scheduleAliveness(me: Me): Me {\n    this.alive = true;\n    timer(0, this.configuration.aliveIntervalInMs).pipe(\n      takeWhile(() => this.alive)\n    )\n    .subscribe(() => this.meRepository.updateAliveness(me));\n    return me;\n  }\n\n  private hasCachedMe(): boolean {\n    return this.cachedMe !== undefined;\n  }\n\n  private connectSocket(me: Me): Me {\n    if (!this.socketClient.socketExists()) {\n      const socket = this.socketClient.connect(this.tokenConfiguration.apiToken);\n      socket.on(\"new message\", data => this.receiveNewMessage(data));\n      socket.on(\"connected\", data => me.deviceSessionId = data.deviceSessionId);\n    }\n    return me;\n  }\n\n  private receiveNewMessage(json: any) {\n    const message = Message.build(json.data);\n    this.me().subscribe(me => me.handleNewMessage(message));\n  }\n}\n","import { Pipe, PipeTransform } from \"@angular/core\";\nimport * as momentLoaded from \"moment\";\nimport { Room } from \"../room/room.types\";\nconst moment = momentLoaded;\n\n@Pipe({\n  name: \"sortRooms\"\n})\nexport class SortRoomPipe  implements PipeTransform {\n  transform(rooms: Room[], field: string): any[] {\n    if (rooms !== undefined && rooms !== null) {\n      return rooms.sort((room: Room, otherRoom: Room) => {\n        const lastActivityAt      = room.lastActivityAt;\n        const otherLastActivityAt = otherRoom.lastActivityAt;\n        if (moment(lastActivityAt).isBefore(otherLastActivityAt)) {\n          return 1;\n        } else if (moment(otherLastActivityAt).isBefore(lastActivityAt)) {\n          return -1;\n        } else {\n          return 0;\n        }\n      });\n    } else {\n      return rooms;\n    }\n  }\n}\n","import { HTTP_INTERCEPTORS, HttpClientModule } from \"@angular/common/http\";\nimport { ModuleWithProviders, NgModule } from \"@angular/core\";\nimport { HttpAuthenticationInterceptor } from \"./authentication/http-authentication-interceptor\";\nimport { TokenConfiguration } from \"./configuration/token-configuration.types\";\nimport { BabiliUrlConfiguration, URL_CONFIGURATION } from \"./configuration/url-configuration.types\";\nimport { MeRepository } from \"./me/me.repository\";\nimport { MeService } from \"./me/me.service\";\nimport { MessageRepository } from \"./message/message.repository\";\nimport { SortRoomPipe } from \"./pipe/sort-room\";\nimport { RoomRepository } from \"./room/room.repository\";\nimport { BootstrapSocket } from \"./socket/bootstrap.socket\";\n\n@NgModule({\n  imports: [\n    HttpClientModule\n  ],\n  declarations: [\n    SortRoomPipe\n  ],\n  exports: [\n    SortRoomPipe\n  ]\n })\nexport class BabiliModule {\n  static forRoot(urlConfiguration: BabiliUrlConfiguration): ModuleWithProviders {\n    return {\n      ngModule: BabiliModule,\n      providers: [\n        {\n          provide: URL_CONFIGURATION,\n          useValue: urlConfiguration\n        },\n        SortRoomPipe,\n        TokenConfiguration,\n        BootstrapSocket,\n        {\n          provide: HTTP_INTERCEPTORS,\n          useClass: HttpAuthenticationInterceptor,\n          multi: true\n        },\n        MessageRepository,\n        RoomRepository,\n        MeRepository,\n        MeService\n      ]\n    };\n  }\n}\n"]}